

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>9.2. Tomography &mdash; CHERAB 1.01 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="9.3. Utilities" href="utility.html" />
    <link rel="prev" title="9.1. Observers" href="observers.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> CHERAB
          

          
          </a>

          
            
            
              <div class="version">
                1.01
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Table of Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../welcome.html">1. Welcome</a></li>
<li class="toctree-l1"><a class="reference internal" href="../licence.html">2. Licence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation_and_structure.html">3. Installation and Project Structure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../available_modules.html">4. Available Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../atomic/atomic_data.html">5. Atomic Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../plasmas/plasmas.html">6. Plasmas</a></li>
<li class="toctree-l1"><a class="reference internal" href="../models/emission_models.html">7. Emission Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../math.html">8. Math functions</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="tools.html">9. Tools</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="observers.html">9.1. Observers</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">9.2. Tomography</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#inversion-methods">9.2.1. Inversion Methods</a></li>
<li class="toctree-l3"><a class="reference internal" href="#voxels">9.2.2. Voxels</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="utility.html">9.3. Utilities</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Demonstrations</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../demonstrations/demonstrations.html">Atomic Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../demonstrations/demonstrations.html#creating-plasmas">Creating Plasmas</a></li>
<li class="toctree-l1"><a class="reference internal" href="../demonstrations/demonstrations.html#code-examples-gallery">Code examples gallery</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">CHERAB</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="tools.html">9. Tools</a> &raquo;</li>
        
      <li>9.2. Tomography</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/tools/tomography.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="tomography">
<h1>9.2. Tomography<a class="headerlink" href="#tomography" title="Permalink to this headline">¶</a></h1>
<p>Tomographic inversion problems often arise in the study of plasma diagnostics, especially
when making line integrated measurements. Tomographic inversion techniques allow us to
try recovering the underlying plasma properties from a reduced set of measurements. In CHERAB
we implement a basic set of tomography algorithms, for a wider range of options please
consult the dedicated tomography libraries such as <a class="reference external" href="https://github.com/ToFuProject/tofu">ToFu</a>.</p>
<p>In general, recovering a plasma emission profile with tomography is an ill-posed problem.
It is customary to describe the system in terms of a sensitivity matrix <span class="math notranslate nohighlight">\(\mathbf{W}\)</span>. The
elements <span class="math notranslate nohighlight">\(W_{k,l}\)</span> describe the coupling between the <span class="math notranslate nohighlight">\(N_s\)</span> plasma emission voxels
<span class="math notranslate nohighlight">\(x_l\)</span> and measured power <span class="math notranslate nohighlight">\(\Phi_k\)</span> at <span class="math notranslate nohighlight">\(N_d\)</span> detectors. The whole detector set
is typically represented as the matrix equation</p>
<div class="math notranslate nohighlight">
\[\mathbf{\Phi} = \mathbf{W} \mathbf{x}.\]</div>
<p>The power for the <em>k</em> th detector can be expressed as</p>
<div class="math notranslate nohighlight">
\[\Phi_k = \sum_{l=1}^{N_s} W_{k,l} \, x_l,\]</div>
<p>where <span class="math notranslate nohighlight">\(k\)</span> and <span class="math notranslate nohighlight">\(l\)</span> are the indices for the detectors and source voxels respectively.</p>
<p>In this module we implement a number of basic inversion algorithms for recovering the emissivity
vector <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> from a set of measurements <span class="math notranslate nohighlight">\(\mathbf{\Phi}\)</span> and sensitivity
matrix <span class="math notranslate nohighlight">\(\mathbf{W}\)</span>.</p>
<div class="section" id="inversion-methods">
<h2>9.2.1. Inversion Methods<a class="headerlink" href="#inversion-methods" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="cherab.tools.inversions.sart.invert_sart">
<code class="descclassname">cherab.tools.inversions.sart.</code><code class="descname">invert_sart</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cherab.tools.inversions.sart.invert_sart" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a SART inversion on the specified measurement vector.</p>
<p>This function implements the Simultaneous Algebraic Reconstruction Technique (SART), as published in
A. Andersen, and A. Kak, Ultrasonic imaging 6, 81 (1984). The SART method is an iterative inversion 
scheme where the source cells are updated with the formula</p>
<div class="math notranslate nohighlight">
\[x_l^{(i+1)} = f_{sart}(x_l^{(i)}) = x_l^{(i)} + \frac{\omega}{W_{\oplus,l}} \sum_{k=1}^{N_d} \frac{W_{k,l}}{W_{k,\oplus}} (\Phi_k - \hat{\Phi}_k),\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[W_{k,\oplus} = \sum_{l=1}^{N_s} W_{k,l}, \quad W_{\oplus, l} = \sum_{k=1}^{N_d} W_{k,l}.\]</div>
<p>Here <span class="math notranslate nohighlight">\(x_l^{(i)}\)</span> is the previous estimate for the emission at voxel <span class="math notranslate nohighlight">\(l\)</span> in iteration <span class="math notranslate nohighlight">\(i\)</span>.
The SART method effectively updates each cell by the weighted average error between the forward modelled
<span class="math notranslate nohighlight">\(\hat{\Phi}_k\)</span> and observed <span class="math notranslate nohighlight">\(\Phi_k\)</span> measurements. The observed errors are weighted by both
their proportion of the total ray length (<span class="math notranslate nohighlight">\(W_{k,\oplus}\)</span>) and the sum of the effective ray paths 
crossing that cell (<span class="math notranslate nohighlight">\(W_{\oplus, l}\)</span>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>geometry_matrix</strong> (<em>np.ndarray</em>) – The sensitivity matrix describing the coupling between the detectors
and the voxels. Must be an array with shape <span class="math notranslate nohighlight">\((N_d, N_s)\)</span>.</li>
<li><strong>measurement_vector</strong> (<em>np.ndarray</em>) – The measured power/radiance vector with shape <span class="math notranslate nohighlight">\((N_d)\)</span>.</li>
<li><strong>initial_guess</strong> – An optional initial guess, can be an array of shape <span class="math notranslate nohighlight">\((N_s)\)</span> or a constant
value that will be used to seed the algorithm.</li>
<li><strong>max_iterations</strong> (<em>int</em>) – The maximum number of iterations to run the SART algorithm before returning
a result, defaults to <cite>max_iterations=250</cite>.</li>
<li><strong>relaxation</strong> (<em>float</em>) – The relaxation hyperparameter, defaults to <cite>relaxation=1</cite>. Consult the reference
papers for more information on this hyperparameter.</li>
<li><strong>conv_tol</strong> (<em>float</em>) – The convergence limit at which the algorithm will be terminated, unless the maximum
number of iterations has been reached. The convergence is calculated as the normalised squared difference
between the measurement and solution vectors.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A tuple with the inverted solution vector <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> as an ndarray with shape <span class="math notranslate nohighlight">\((N_s)\)</span>,
and the convergence achieved as a float.</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cherab.tools.inversions</span> <span class="kn">import</span> <span class="n">invert_sart</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inverted_solution</span><span class="p">,</span> <span class="n">conv</span> <span class="o">=</span> <span class="n">invert_sart</span><span class="p">(</span><span class="n">weight_matrix</span><span class="p">,</span> <span class="n">observations</span><span class="p">,</span> <span class="n">max_iterations</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>    
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="cherab.tools.inversions.sart.invert_constrained_sart">
<code class="descclassname">cherab.tools.inversions.sart.</code><code class="descname">invert_constrained_sart</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cherab.tools.inversions.sart.invert_constrained_sart" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a constrained SART inversion on the specified measurement vector.</p>
<p>The core of the constrained SART algorithm is identical to the basic SART algorithm implemented in 
<cite>invert_sart()</cite>. The only difference is that now the iterative update formula includes a 
regularisation operator.</p>
<div class="math notranslate nohighlight">
\[x_l^{(i+1)} = f_{sart}(x_l^{(i)}) - \hat{\mathcal{L}}_{iso}(x_l^{(i)}).\]</div>
<p>In this particular function we have implemented a isotropic Laplacian smoothness operator,</p>
<div class="math notranslate nohighlight">
\[\hat{\mathcal{L}}_{iso}(x_l^{(i)}) = \beta_L (Cx_l^{(i)} - \sum_{c=1}^C x_c^{(i)}).\]</div>
<p>Here, <span class="math notranslate nohighlight">\(c\)</span> is the index for the sum over the neighbouring voxels. The regularisation 
hyperparameter <span class="math notranslate nohighlight">\(\beta_L\)</span> determines the amount of local smoothness imposed on the
solution vector. When <span class="math notranslate nohighlight">\(\beta_L = 0\)</span>, the solution is fully determined by the 
measurements, and as <span class="math notranslate nohighlight">\(\beta_L \rightarrow 1\)</span>, the solution is dominated by the 
smoothness operator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>geometry_matrix</strong> (<em>np.ndarray</em>) – The sensitivity matrix describing the coupling between the detectors
and the voxels. Must be an array with shape <span class="math notranslate nohighlight">\((N_d, N_s)\)</span>.</li>
<li><strong>laplacian_matrix</strong> (<em>np.ndarray</em>) – The laplacian regularisation matrix of shape <span class="math notranslate nohighlight">\((N_s, N_s)\)</span>.</li>
<li><strong>measurement_vector</strong> (<em>np.ndarray</em>) – The measured power/radiance vector with shape <span class="math notranslate nohighlight">\((N_d)\)</span>.</li>
<li><strong>initial_guess</strong> – An optional initial guess, can be an array of shape <span class="math notranslate nohighlight">\((N_s)\)</span> or a constant
value that will be used to seed the algorithm.</li>
<li><strong>max_iterations</strong> (<em>int</em>) – The maximum number of iterations to run the SART algorithm before returning
a result, defaults to <cite>max_iterations=250</cite>.</li>
<li><strong>relaxation</strong> (<em>float</em>) – The relaxation hyperparameter, defaults to <cite>relaxation=1</cite>. Consult the reference
papers for more information on this hyperparameter.</li>
<li><strong>beta_laplace</strong> (<em>float</em>) – The regularisation hyperparameter in the range [0, 1]. Defaults
to <cite>beta_laplace=0.01</cite>.</li>
<li><strong>conv_tol</strong> (<em>float</em>) – The convergence limit at which the algorithm will be terminated, unless the maximum
number of iterations has been reached. The convergence is calculated as the normalised squared difference
between the measurement and solution vectors.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A tuple with the inverted solution vector <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> as an ndarray with shape <span class="math notranslate nohighlight">\((N_s)\)</span>,
and the convergence achieved as a float.</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cherab.tools.inversions</span> <span class="kn">import</span> <span class="n">invert_constrained_sart</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inverted_solution</span><span class="p">,</span> <span class="n">conv</span> <span class="o">=</span> <span class="n">invert_constrained_sart</span><span class="p">(</span><span class="n">weight_matrix</span><span class="p">,</span> <span class="n">laplacian</span><span class="p">,</span> <span class="n">observations</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="cherab.tools.inversions.nnls.invert_regularised_nnls">
<code class="descclassname">cherab.tools.inversions.nnls.</code><code class="descname">invert_regularised_nnls</code><span class="sig-paren">(</span><em>w_matrix</em>, <em>b_vector</em>, <em>alpha=0.01</em>, <em>tikhonov_matrix=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cherab.tools.inversions.nnls.invert_regularised_nnls" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves <span class="math notranslate nohighlight">\(\mathbf{b} = \mathbf{W} \mathbf{x}\)</span> for the vector <span class="math notranslate nohighlight">\(\mathbf{x}\)</span>,
using Tikhonov regulariastion.</p>
<p>This is a thin wrapper around scipy.optimize.nnls, which modifies
the arguments to include the supplied Tikhonov regularisation matrix.</p>
<p>If tikhonov_matrix is None, the matrix used is alpha times the
identity matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>w_matrix</strong> (<em>np.ndarray</em>) – The sensitivity matrix describing the coupling between the
detectors and the voxels. Must be an array with shape <span class="math notranslate nohighlight">\((N_d, N_s)\)</span>.</li>
<li><strong>b_vector</strong> (<em>np.ndarray</em>) – The measured power/radiance vector with shape <span class="math notranslate nohighlight">\((N_d)\)</span>.</li>
<li><strong>alpha</strong> (<em>float</em>) – The regularisation hyperparameter <span class="math notranslate nohighlight">\(lpha\)</span> which determines
the regularisation strength of the tikhonov matrix.</li>
<li><strong>tikhonov_matrix</strong> (<em>np.ndarray</em>) – The tikhonov regularisation matrix operator, an array
with shape <span class="math notranslate nohighlight">\((N_s, N_s)\)</span>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(x, norm), the solution vector and the residual norm.</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cherab.tools.inversions</span> <span class="kn">import</span> <span class="n">invert_regularised_nnls</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">norm</span> <span class="o">=</span> <span class="n">invert_regularised_nnls</span><span class="p">(</span><span class="n">w_matrix</span><span class="p">,</span> <span class="n">b_vector</span><span class="p">,</span> <span class="n">tikhonov_matrix</span><span class="o">=</span><span class="n">tikhonov_matrix</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="cherab.tools.inversions.svd.invert_svd">
<code class="descclassname">cherab.tools.inversions.svd.</code><code class="descname">invert_svd</code><span class="sig-paren">(</span><em>w_matrix</em>, <em>b_vector</em><span class="sig-paren">)</span><a class="headerlink" href="#cherab.tools.inversions.svd.invert_svd" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a Singular Value Decomposition (SVD) operation inversion.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>w_matrix</strong> (<em>np.ndarray</em>) – The sensitivity matrix describing the coupling between the
detectors and the voxels. Must be an array with shape <span class="math notranslate nohighlight">\((N_d, N_s)\)</span>.</li>
<li><strong>b_vector</strong> (<em>np.ndarray</em>) – The measured power/radiance vector with shape <span class="math notranslate nohighlight">\((N_d)\)</span>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The solution vector x as an ndarray.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="voxels">
<h2>9.2.2. Voxels<a class="headerlink" href="#voxels" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="cherab.tools.inversions.voxels.Voxel">
<em class="property">class </em><code class="descclassname">cherab.tools.inversions.voxels.</code><code class="descname">Voxel</code><a class="headerlink" href="#cherab.tools.inversions.voxels.Voxel" title="Permalink to this definition">¶</a></dt>
<dd><p>A Voxel base class.</p>
<p>Each Voxel is a Node in the scenegraph. Each Voxel type that
inherits from this class defines its own geometry.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><strong>volume</strong> (<em>float</em>) – The geometric volume of this voxel.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="cherab.tools.inversions.voxels.AxisymmetricVoxel">
<em class="property">class </em><code class="descclassname">cherab.tools.inversions.voxels.</code><code class="descname">AxisymmetricVoxel</code><a class="headerlink" href="#cherab.tools.inversions.voxels.AxisymmetricVoxel" title="Permalink to this definition">¶</a></dt>
<dd><p>An axis-symmetric Voxel.</p>
<p>This Voxel is symmetric about the vertical z-axis. The cross section
of the voxel can be arbitrarily defined by a polygon in the r-z plane.
The type of geometric primitive used to define the geometric extent of
this Voxel can be selected by the user and either of type Mesh or CSG.
The two representations should approximately the same geometry but have
different performance goals. The CSG representation uses lower memory and
is a better choice when large numbers of Voxels will be present in a single
scene. The Mesh representation is split into smaller components and better
for cases where multiple importance sampling is important, such as weight
matrices including reflection effects.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>vertices</strong> – A list/tuple of Point2D objects specifying the voxel’s
polygon outline in the r-z plane.</li>
<li><strong>parent</strong> (<em>Node</em>) – The scenegraph to which this Voxel is attached.</li>
<li><strong>material</strong> (<em>Material</em>) – The emission material of this Voxel, defaults
to a UnityVolumeEmitter() for weight matrix calculations.</li>
<li><strong>primitive_type</strong> (<em>str</em>) – Specifies the primitive type, can be either
‘mesh’ or ‘csg’. Defaults to the mesh representation.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>volume</strong> (<em>float</em>) – The geometric volume of this voxel.</li>
<li><strong>cross_sectional_area</strong> (<em>float</em>) – The cross sectional area of the voxel in
the r-z plane.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="cherab.tools.inversions.voxels.VoxelCollection">
<em class="property">class </em><code class="descclassname">cherab.tools.inversions.voxels.</code><code class="descname">VoxelCollection</code><a class="headerlink" href="#cherab.tools.inversions.voxels.VoxelCollection" title="Permalink to this definition">¶</a></dt>
<dd><p>The base class for collections of voxels.</p>
<p>Used for managing a collection of voxels when calculating a weight
matrix for example.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>count</strong> (<em>float</em>) – The number of voxels in this collection.</li>
<li><strong>total_volume</strong> (<em>float</em>) – The total volume of all voxels.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="cherab.tools.inversions.voxels.VoxelCollection.emissivities_from_function">
<code class="descname">emissivities_from_function</code><a class="headerlink" href="#cherab.tools.inversions.voxels.VoxelCollection.emissivities_from_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an array of sampled emissivities at each voxel location.</p>
<p>This is a virtual method and must be implemented in the derived
VoxelCollection class.</p>
<p>Note that the results will be nonsense if you mix an emission function
and VoxelCollection with incompatible symmetries.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>emission_function</strong> (<em>Function3D</em>) – Emission function to sample over.</li>
<li><strong>grid_samples</strong> (<em>int</em>) – Number of emission samples to average over.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">np.ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="cherab.tools.inversions.voxels.VoxelCollection.parent_all_voxels">
<code class="descname">parent_all_voxels</code><a class="headerlink" href="#cherab.tools.inversions.voxels.VoxelCollection.parent_all_voxels" title="Permalink to this definition">¶</a></dt>
<dd><p>Add all voxels in this collection to the scenegraph.</p>
</dd></dl>

<dl class="attribute">
<dt id="cherab.tools.inversions.voxels.VoxelCollection.set_active">
<code class="descname">set_active</code><a class="headerlink" href="#cherab.tools.inversions.voxels.VoxelCollection.set_active" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the ith voxel as an active emitter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>item</strong> – If item is an int, the ith voxel will be configured as an active emitter,
all the others will be turned off. If item is the string ‘all’, all voxels will be
active emitters.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="cherab.tools.inversions.voxels.VoxelCollection.unparent_all_voxels">
<code class="descname">unparent_all_voxels</code><a class="headerlink" href="#cherab.tools.inversions.voxels.VoxelCollection.unparent_all_voxels" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all voxels in this collection from the scenegraph.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cherab.tools.inversions.voxels.ToroidalVoxelGrid">
<em class="property">class </em><code class="descclassname">cherab.tools.inversions.voxels.</code><code class="descname">ToroidalVoxelGrid</code><a class="headerlink" href="#cherab.tools.inversions.voxels.ToroidalVoxelGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>A collection of axis-symmetric toroidal voxels.</p>
<p>This object manages a collection of voxels, where each voxel in the collection
is an AxisymmetricVoxel object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>voxel_coordinates</strong> – An array/list of voxels, where each voxel element
is defined by a list of 2D points.</li>
<li><strong>name</strong> (<em>str</em>) – The name of this voxel collection.</li>
<li><strong>parent</strong> (<em>Node</em>) – The parent scenegraph to which these voxels belong.</li>
<li><strong>transform</strong> (<em>AffineMatrix3D</em>) – The coordinate transformation of this local
coordinate system relative to the scenegraph parent, defaults to the identity
transform.</li>
<li><strong>active</strong> – Selects which voxels are active emitters in the initialised state.
If active is an int, the ith voxel will be configured as an active emitter, all
the others will be turned off. If active is the string ‘all’, all voxels will be
active emitters.</li>
<li><strong>primitive_type</strong> (<em>str</em>) – The geometry type to use for the AxisymmetricVoxel
instances, can be [‘mesh’, ‘csg’]. See their documentation for more information.
Defaults to <cite>primitive_type=’mesh’</cite>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="cherab.tools.inversions.voxels.ToroidalVoxelGrid.emissivities_from_function">
<code class="descname">emissivities_from_function</code><a class="headerlink" href="#cherab.tools.inversions.voxels.ToroidalVoxelGrid.emissivities_from_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an array of sampled emissivities at each voxel location.</p>
<p>Note that the results will be nonsense if you mix an emission function
and VoxelCollection with incompatible symmetries.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>emission_function</strong> (<em>Function3D</em>) – Emission function to sample over.</li>
<li><strong>grid_samples</strong> (<em>int</em>) – Number of emission samples to average over.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">np.ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="cherab.tools.inversions.voxels.ToroidalVoxelGrid.plot">
<code class="descname">plot</code><a class="headerlink" href="#cherab.tools.inversions.voxels.ToroidalVoxelGrid.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots a voxel grid.</p>
<p>If no voxel data values are provided, the plot is an outline of the grid in the r-z plane. If
voxel values are provided, this method plots the voxel grid coloured by the voxel intensities.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>title</strong> (<em>str</em>) – The title of the plot.</li>
<li><strong>voxel_values</strong> (<em>np.ndarray</em>) – A 1D numpy array with length equal to the number of voxels
in the collection.</li>
<li><strong>ax</strong> – The matplotlib Axes object on which the plot will be made. If None, this function
generates a new plot.</li>
<li><strong>vmin</strong> (<em>float</em>) – The minimum value for the colour map.</li>
<li><strong>vmax</strong> (<em>float</em>) – The maximum value for the colour map.</li>
<li><strong>cmap</strong> – The matplotlib colour map to use for colouring the voxel intensities.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="utility.html" class="btn btn-neutral float-right" title="9.3. Utilities" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="observers.html" class="btn btn-neutral" title="9.1. Observers" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, CHERAB Team.

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1.01',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
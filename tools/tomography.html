

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>10.5. Tomography &mdash; CHERAB 1.01 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="10.6. Utilities" href="utility.html" />
    <link rel="prev" title="10.4. Observers" href="observers.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> CHERAB
          

          
          </a>

          
            
            
              <div class="version">
                1.01
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Table of Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../welcome.html">1. Welcome</a></li>
<li class="toctree-l1"><a class="reference internal" href="../licence.html">2. Licence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../governance.html">3. Project Governance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation_and_structure.html">4. Installation and Project Structure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../available_modules.html">5. Available Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../atomic/atomic_data.html">6. Atomic Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../plasmas/plasmas.html">7. Plasmas</a></li>
<li class="toctree-l1"><a class="reference internal" href="../models/emission_models.html">8. Emission Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../math/math.html">9. Function Framework</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="tools.html">10. Tools</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="plasmas.html">10.1. Plasmas</a></li>
<li class="toctree-l2"><a class="reference internal" href="materials.html">10.2. Materials</a></li>
<li class="toctree-l2"><a class="reference internal" href="primitives.html">10.3. Primitives</a></li>
<li class="toctree-l2"><a class="reference internal" href="observers.html">10.4. Observers</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">10.5. Tomography</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#inversion-methods">10.5.1. Inversion Methods</a></li>
<li class="toctree-l3"><a class="reference internal" href="#voxels">10.5.2. Voxels</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="utility.html">10.6. Utilities</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Demonstrations</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../demonstrations/demonstrations.html">Atomic Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../demonstrations/demonstrations.html#creating-plasmas">Creating Plasmas</a></li>
<li class="toctree-l1"><a class="reference internal" href="../demonstrations/demonstrations.html#surface-radiation-loads">Surface Radiation Loads</a></li>
<li class="toctree-l1"><a class="reference internal" href="../demonstrations/demonstrations.html#active-spectroscopy">Active Spectroscopy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../demonstrations/demonstrations.html#passive-spectroscopy">Passive Spectroscopy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../demonstrations/demonstrations.html#code-examples-gallery">Code examples gallery</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">CHERAB</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="tools.html">10. Tools</a> &raquo;</li>
        
      <li>10.5. Tomography</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/tools/tomography.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="tomography">
<h1>10.5. Tomography<a class="headerlink" href="#tomography" title="Permalink to this headline">¶</a></h1>
<p>Tomographic inversion problems often arise in the study of plasma diagnostics, especially
when making line integrated measurements. Tomographic inversion techniques allow us to
try recovering the underlying plasma properties from a reduced set of measurements. In CHERAB
we implement a basic set of tomography algorithms, for a wider range of options please
consult the dedicated tomography libraries such as <a class="reference external" href="https://github.com/ToFuProject/tofu">ToFu</a>.</p>
<p>In general, recovering a plasma emission profile with tomography is an ill-posed problem.
It is customary to describe the system in terms of a sensitivity matrix <span class="math notranslate nohighlight">\(\mathbf{W}\)</span>. The
elements <span class="math notranslate nohighlight">\(W_{k,l}\)</span> describe the coupling between the <span class="math notranslate nohighlight">\(N_s\)</span> plasma emission voxels
<span class="math notranslate nohighlight">\(x_l\)</span> and measured power <span class="math notranslate nohighlight">\(\Phi_k\)</span> at <span class="math notranslate nohighlight">\(N_d\)</span> detectors. The whole detector set
is typically represented as the matrix equation</p>
<div class="math notranslate nohighlight">
\[\mathbf{\Phi} = \mathbf{W} \mathbf{x}.\]</div>
<p>The power for the <em>k</em> th detector can be expressed as</p>
<div class="math notranslate nohighlight">
\[\Phi_k = \sum_{l=1}^{N_s} W_{k,l} \, x_l,\]</div>
<p>where <span class="math notranslate nohighlight">\(k\)</span> and <span class="math notranslate nohighlight">\(l\)</span> are the indices for the detectors and source voxels respectively.</p>
<p>In this module we implement a number of basic inversion algorithms for recovering the emissivity
vector <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> from a set of measurements <span class="math notranslate nohighlight">\(\mathbf{\Phi}\)</span> and sensitivity
matrix <span class="math notranslate nohighlight">\(\mathbf{W}\)</span>.</p>
<div class="section" id="inversion-methods">
<h2>10.5.1. Inversion Methods<a class="headerlink" href="#inversion-methods" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="cherab.tools.inversions.sart.invert_sart">
<code class="descclassname">cherab.tools.inversions.sart.</code><code class="descname">invert_sart</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cherab.tools.inversions.sart.invert_sart" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a SART inversion on the specified measurement vector.</p>
<p>This function implements the Simultaneous Algebraic Reconstruction Technique (SART), as published in
A. Andersen, and A. Kak, Ultrasonic imaging 6, 81 (1984). The SART method is an iterative inversion 
scheme where the source cells are updated with the formula</p>
<div class="math notranslate nohighlight">
\[x_l^{(i+1)} = f_{sart}(x_l^{(i)}) = x_l^{(i)} + \frac{\omega}{W_{\oplus,l}} \sum_{k=1}^{N_d} \frac{W_{k,l}}{W_{k,\oplus}} (\Phi_k - \hat{\Phi}_k),\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[W_{k,\oplus} = \sum_{l=1}^{N_s} W_{k,l}, \quad W_{\oplus, l} = \sum_{k=1}^{N_d} W_{k,l}.\]</div>
<p>Here <span class="math notranslate nohighlight">\(x_l^{(i)}\)</span> is the previous estimate for the emission at voxel <span class="math notranslate nohighlight">\(l\)</span> in iteration <span class="math notranslate nohighlight">\(i\)</span>.
The SART method effectively updates each cell by the weighted average error between the forward modelled
<span class="math notranslate nohighlight">\(\hat{\Phi}_k\)</span> and observed <span class="math notranslate nohighlight">\(\Phi_k\)</span> measurements. The observed errors are weighted by both
their proportion of the total ray length (<span class="math notranslate nohighlight">\(W_{k,\oplus}\)</span>) and the sum of the effective ray paths 
crossing that cell (<span class="math notranslate nohighlight">\(W_{\oplus, l}\)</span>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>geometry_matrix</strong> (<em>np.ndarray</em>) – The sensitivity matrix describing the coupling between the detectors
and the voxels. Must be an array with shape <span class="math notranslate nohighlight">\((N_d, N_s)\)</span>.</li>
<li><strong>measurement_vector</strong> (<em>np.ndarray</em>) – The measured power/radiance vector with shape <span class="math notranslate nohighlight">\((N_d)\)</span>.</li>
<li><strong>initial_guess</strong> – An optional initial guess, can be an array of shape <span class="math notranslate nohighlight">\((N_s)\)</span> or a constant
value that will be used to seed the algorithm.</li>
<li><strong>max_iterations</strong> (<em>int</em>) – The maximum number of iterations to run the SART algorithm before returning
a result, defaults to <cite>max_iterations=250</cite>.</li>
<li><strong>relaxation</strong> (<em>float</em>) – The relaxation hyperparameter, defaults to <cite>relaxation=1</cite>. Consult the reference
papers for more information on this hyperparameter.</li>
<li><strong>conv_tol</strong> (<em>float</em>) – The convergence limit at which the algorithm will be terminated, unless the maximum
number of iterations has been reached. The convergence is calculated as the normalised squared difference
between the measurement and solution vectors.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A tuple with the inverted solution vector <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> as an ndarray with shape <span class="math notranslate nohighlight">\((N_s)\)</span>,
and the convergence achieved as a float.</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cherab.tools.inversions</span> <span class="kn">import</span> <span class="n">invert_sart</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inverted_solution</span><span class="p">,</span> <span class="n">conv</span> <span class="o">=</span> <span class="n">invert_sart</span><span class="p">(</span><span class="n">weight_matrix</span><span class="p">,</span> <span class="n">observations</span><span class="p">,</span> <span class="n">max_iterations</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>    
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="cherab.tools.inversions.sart.invert_constrained_sart">
<code class="descclassname">cherab.tools.inversions.sart.</code><code class="descname">invert_constrained_sart</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cherab.tools.inversions.sart.invert_constrained_sart" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a constrained SART inversion on the specified measurement vector.</p>
<p>The core of the constrained SART algorithm is identical to the basic SART algorithm implemented in 
<cite>invert_sart()</cite>. The only difference is that now the iterative update formula includes a 
regularisation operator.</p>
<div class="math notranslate nohighlight">
\[x_l^{(i+1)} = f_{sart}(x_l^{(i)}) - \hat{\mathcal{L}}_{iso}(x_l^{(i)}).\]</div>
<p>In this particular function we have implemented a isotropic Laplacian smoothness operator,</p>
<div class="math notranslate nohighlight">
\[\hat{\mathcal{L}}_{iso}(x_l^{(i)}) = \beta_L (Cx_l^{(i)} - \sum_{c=1}^C x_c^{(i)}).\]</div>
<p>Here, <span class="math notranslate nohighlight">\(c\)</span> is the index for the sum over the neighbouring voxels. The regularisation 
hyperparameter <span class="math notranslate nohighlight">\(\beta_L\)</span> determines the amount of local smoothness imposed on the
solution vector. When <span class="math notranslate nohighlight">\(\beta_L = 0\)</span>, the solution is fully determined by the 
measurements, and as <span class="math notranslate nohighlight">\(\beta_L \rightarrow 1\)</span>, the solution is dominated by the 
smoothness operator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>geometry_matrix</strong> (<em>np.ndarray</em>) – The sensitivity matrix describing the coupling between the detectors
and the voxels. Must be an array with shape <span class="math notranslate nohighlight">\((N_d, N_s)\)</span>.</li>
<li><strong>laplacian_matrix</strong> (<em>np.ndarray</em>) – The laplacian regularisation matrix of shape <span class="math notranslate nohighlight">\((N_s, N_s)\)</span>.</li>
<li><strong>measurement_vector</strong> (<em>np.ndarray</em>) – The measured power/radiance vector with shape <span class="math notranslate nohighlight">\((N_d)\)</span>.</li>
<li><strong>initial_guess</strong> – An optional initial guess, can be an array of shape <span class="math notranslate nohighlight">\((N_s)\)</span> or a constant
value that will be used to seed the algorithm.</li>
<li><strong>max_iterations</strong> (<em>int</em>) – The maximum number of iterations to run the SART algorithm before returning
a result, defaults to <cite>max_iterations=250</cite>.</li>
<li><strong>relaxation</strong> (<em>float</em>) – The relaxation hyperparameter, defaults to <cite>relaxation=1</cite>. Consult the reference
papers for more information on this hyperparameter.</li>
<li><strong>beta_laplace</strong> (<em>float</em>) – The regularisation hyperparameter in the range [0, 1]. Defaults
to <cite>beta_laplace=0.01</cite>.</li>
<li><strong>conv_tol</strong> (<em>float</em>) – The convergence limit at which the algorithm will be terminated, unless the maximum
number of iterations has been reached. The convergence is calculated as the normalised squared difference
between the measurement and solution vectors.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A tuple with the inverted solution vector <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> as an ndarray with shape <span class="math notranslate nohighlight">\((N_s)\)</span>,
and the convergence achieved as a float.</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cherab.tools.inversions</span> <span class="kn">import</span> <span class="n">invert_constrained_sart</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inverted_solution</span><span class="p">,</span> <span class="n">conv</span> <span class="o">=</span> <span class="n">invert_constrained_sart</span><span class="p">(</span><span class="n">weight_matrix</span><span class="p">,</span> <span class="n">laplacian</span><span class="p">,</span> <span class="n">observations</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="cherab.tools.inversions.opencl.sart_opencl.SartOpencl">
<em class="property">class </em><code class="descclassname">cherab.tools.inversions.opencl.sart_opencl.</code><code class="descname">SartOpencl</code><span class="sig-paren">(</span><em>geometry_matrix</em>, <em>laplacian_matrix=None</em>, <em>device=None</em>, <em>block_size=256</em>, <em>copy_column_major=True</em>, <em>block_size_row_maj=64</em>, <em>use_atomic=True</em>, <em>steps_per_thread=64</em><span class="sig-paren">)</span><a class="headerlink" href="#cherab.tools.inversions.opencl.sart_opencl.SartOpencl" title="Permalink to this definition">¶</a></dt>
<dd><p>A GPU-accelerated version of SART inversion.
The geometry matrix and Laplacian matrix are provided on initialisation because they must be copied
to GPU memory, which takes time. Inversions may be performed multiple times for different measurement
vectors without copying the matrices each time. If required, the Laplacian matrix can be updated
by calling <cite>update_laplacian_matrix(new_laplacian_matrix)</cite> method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>geometry_matrix</strong> (<em>np.ndarray</em>) – The sensitivity matrix describing the coupling between the detectors
and the voxels. Must be an array with shape <span class="math notranslate nohighlight">\((N_d, N_s)\)</span>.</li>
<li><strong>laplacian_matrix</strong> (<em>np.ndarray</em>) – The laplacian regularisation matrix of shape <span class="math notranslate nohighlight">\((N_s, N_s)\)</span>.
Default value: <cite>laplacian_matrix=None</cite>.</li>
<li><strong>device</strong> (<em>pyopencl.Device</em>) – OpenCL device which will be used for computations. Default value: <cite>device=None</cite> (autoselect).</li>
<li><strong>block_size</strong> (<em>int</em>) – Number of GPU threads per block. Must be the power of 2.
For the best performance try from 256 to 1024 for Nvidia (use 1024 on high-end GPUs),
from 64 to 256 for AMD and from 16 to 64 for Intel GPUs. Default value: <cite>block_size=256</cite>.</li>
<li><strong>copy_column_major</strong> (<em>bool</em>) – If True, the two copies of geometry matrix will be stored in the GPU memory.
One in row-major order and the other one in column-major order. This provides much better performance of the
inversions but requires twice as much GPU memory. Default value: <cite>copy_column_major=True</cite>.</li>
<li><strong>block_size_row_maj</strong> (<em>int</em>) – If <cite>copy_column_major</cite> is set to False, this parameter defines the number of GPU threads per block
in mat_vec_mult_row_maj() kernel used to calculate y_hat. Must be lower than <cite>block_size</cite>.
Default value: <cite>block_size_row_maj=64</cite> (optimal value for Nvidia GPUs).</li>
<li><strong>use_atomic</strong> (<em>bool</em>) – If True, increases the number of thread blocks that can run in parallel with the help of atomic
operations (custom atomic add on floats). Set this to False, if the atomic operations are running slow
on your device (Nvidia GPUs before Kepler, some AMD APUs, some Intel GPUs). Default value: <cite>use_atomic=True</cite>.</li>
<li><strong>steps_per_thread</strong> (<em>int</em>) – If <cite>use_atomic</cite> is set to True, this parameters defines the maximum number of loop steps performed
by the parallel threads in a single thread block. Default value: <cite>steps_per_thread=64</cite> (optimal for Nvidia GPUs).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="cherab.tools.inversions.opencl.sart_opencl.SartOpencl.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>measurement_vector</em>, <em>initial_guess=None</em>, <em>max_iterations=250</em>, <em>relaxation=1.0</em>, <em>beta_laplace=0.01</em>, <em>conv_tol=0.0001</em>, <em>time_limit=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cherab.tools.inversions.opencl.sart_opencl.SartOpencl.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs the inversion for a given measurement vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>measurement_vector</strong> (<em>np.ndarray</em>) – The measured power/radiance vector with shape <span class="math notranslate nohighlight">\((N_d)\)</span>.</li>
<li><strong>initial_guess</strong> – An optional initial guess, can be an array of shape <span class="math notranslate nohighlight">\((N_s)\)</span> or a constant
value that will be used to seed the algorithm.</li>
<li><strong>max_iterations</strong> (<em>int</em>) – The maximum number of iterations to run the SART algorithm before returning
a result, defaults to <cite>max_iterations=250</cite>.</li>
<li><strong>relaxation</strong> (<em>float</em>) – The relaxation hyperparameter, defaults to <cite>relaxation=1</cite>. Consult the reference
papers for more information on this hyperparameter.</li>
<li><strong>beta_laplace</strong> (<em>float</em>) – The regularisation hyperparameter in the range [0, 1]. Defaults to <cite>beta_laplace=0.01</cite>.</li>
<li><strong>conv_tol</strong> (<em>float</em>) – The convergence limit at which the algorithm will be terminated, unless the maximum
number of iterations has been reached. The convergence is calculated as the normalised squared difference
between the measurement and solution vectors.</li>
<li><strong>time_limit</strong> (<em>float</em>) – If set, the iterations will stop after this time limit (in seconds) is reached.
Default value: <cite>time_limit=None</cite>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A tuple with the inverted solution vector <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> as an ndarray with shape <span class="math notranslate nohighlight">\((N_s)\)</span>,
and the list of convergence values achieved after each iteration step.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cherab.tools.inversions.opencl.sart_opencl.SartOpencl.clean">
<code class="descname">clean</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cherab.tools.inversions.opencl.sart_opencl.SartOpencl.clean" title="Permalink to this definition">¶</a></dt>
<dd><p>Releases GPU buffers</p>
</dd></dl>

<dl class="method">
<dt id="cherab.tools.inversions.opencl.sart_opencl.SartOpencl.update_laplacian_matrix">
<code class="descname">update_laplacian_matrix</code><span class="sig-paren">(</span><em>laplacian_matrix</em><span class="sig-paren">)</span><a class="headerlink" href="#cherab.tools.inversions.opencl.sart_opencl.SartOpencl.update_laplacian_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates the Laplacian matrix in GPU memory</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>laplacian_matrix</strong> (<em>np.ndarray</em>) – The laplacian regularisation matrix of shape <span class="math notranslate nohighlight">\((N_s, N_s)\)</span>.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="cherab.tools.inversions.nnls.invert_regularised_nnls">
<code class="descclassname">cherab.tools.inversions.nnls.</code><code class="descname">invert_regularised_nnls</code><span class="sig-paren">(</span><em>w_matrix</em>, <em>b_vector</em>, <em>alpha=0.01</em>, <em>tikhonov_matrix=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cherab.tools.inversions.nnls.invert_regularised_nnls" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves <span class="math notranslate nohighlight">\(\mathbf{b} = \mathbf{W} \mathbf{x}\)</span> for the vector <span class="math notranslate nohighlight">\(\mathbf{x}\)</span>,
using Tikhonov regulariastion.</p>
<p>This is a thin wrapper around scipy.optimize.nnls, which modifies
the arguments to include the supplied Tikhonov regularisation matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>w_matrix</strong> (<em>np.ndarray</em>) – The sensitivity matrix describing the coupling between the
detectors and the voxels. Must be an array with shape <span class="math notranslate nohighlight">\((N_d, N_s)\)</span>.</li>
<li><strong>b_vector</strong> (<em>np.ndarray</em>) – The measured power/radiance vector with shape <span class="math notranslate nohighlight">\((N_d)\)</span>.</li>
<li><strong>alpha</strong> (<em>float</em>) – The regularisation hyperparameter <span class="math notranslate nohighlight">\(lpha\)</span> which determines
the regularisation strength of the tikhonov matrix.</li>
<li><strong>tikhonov_matrix</strong> (<em>np.ndarray</em>) – The tikhonov regularisation matrix operator, an array
with shape <span class="math notranslate nohighlight">\((N_s, N_s)\)</span>. If None, the identity matrix is used.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(x, norm), the solution vector and the residual norm.</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cherab.tools.inversions</span> <span class="kn">import</span> <span class="n">invert_regularised_nnls</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">norm</span> <span class="o">=</span> <span class="n">invert_regularised_nnls</span><span class="p">(</span><span class="n">w_matrix</span><span class="p">,</span> <span class="n">b_vector</span><span class="p">,</span> <span class="n">tikhonov_matrix</span><span class="o">=</span><span class="n">tikhonov_matrix</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="cherab.tools.inversions.svd.invert_svd">
<code class="descclassname">cherab.tools.inversions.svd.</code><code class="descname">invert_svd</code><span class="sig-paren">(</span><em>w_matrix</em>, <em>b_vector</em><span class="sig-paren">)</span><a class="headerlink" href="#cherab.tools.inversions.svd.invert_svd" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a Singular Value Decomposition (SVD) operation inversion.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>w_matrix</strong> (<em>np.ndarray</em>) – The sensitivity matrix describing the coupling between the
detectors and the voxels. Must be an array with shape <span class="math notranslate nohighlight">\((N_d, N_s)\)</span>.</li>
<li><strong>b_vector</strong> (<em>np.ndarray</em>) – The measured power/radiance vector with shape <span class="math notranslate nohighlight">\((N_d)\)</span>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The solution vector x as an ndarray.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="voxels">
<h2>10.5.2. Voxels<a class="headerlink" href="#voxels" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="cherab.tools.inversions.voxels.Voxel">
<em class="property">class </em><code class="descclassname">cherab.tools.inversions.voxels.</code><code class="descname">Voxel</code><a class="headerlink" href="#cherab.tools.inversions.voxels.Voxel" title="Permalink to this definition">¶</a></dt>
<dd><p>A Voxel base class.</p>
<p>Each Voxel is a Node in the scenegraph. Each Voxel type that
inherits from this class defines its own geometry.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><strong>volume</strong> (<em>float</em>) – The geometric volume of this voxel.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="cherab.tools.inversions.voxels.AxisymmetricVoxel">
<em class="property">class </em><code class="descclassname">cherab.tools.inversions.voxels.</code><code class="descname">AxisymmetricVoxel</code><a class="headerlink" href="#cherab.tools.inversions.voxels.AxisymmetricVoxel" title="Permalink to this definition">¶</a></dt>
<dd><p>An axis-symmetric Voxel.</p>
<p>This Voxel is symmetric about the vertical z-axis. The cross section
of the voxel can be arbitrarily defined by a polygon in the r-z plane.
The type of geometric primitive used to define the geometric extent of
this Voxel can be selected by the user and either of type Mesh or CSG.
The two representations should approximately the same geometry but have
different performance goals. The CSG representation uses lower memory and
is a better choice when large numbers of Voxels will be present in a single
scene. The Mesh representation is split into smaller components and better
for cases where multiple importance sampling is important, such as weight
matrices including reflection effects.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>vertices</strong> – A list/tuple of Point2D objects specifying the voxel’s
polygon outline in the r-z plane.</li>
<li><strong>parent</strong> (<em>Node</em>) – The scenegraph to which this Voxel is attached.</li>
<li><strong>material</strong> (<em>Material</em>) – The emission material of this Voxel, defaults
to a UnityVolumeEmitter() for weight matrix calculations.</li>
<li><strong>primitive_type</strong> (<em>str</em>) – Specifies the primitive type, can be either
‘mesh’ or ‘csg’. Defaults to the CSG representation.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>volume</strong> (<em>float</em>) – The geometric volume of this voxel.</li>
<li><strong>cross_sectional_area</strong> (<em>float</em>) – The cross sectional area of the voxel in
the r-z plane.</li>
<li><strong>cross_section_centroid</strong> (<em>Point2D</em>) – The centroid of the voxel in
the r-z plane.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="cherab.tools.inversions.voxels.AxisymmetricVoxel.emissivity_from_function">
<code class="descname">emissivity_from_function</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cherab.tools.inversions.voxels.AxisymmetricVoxel.emissivity_from_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the average emissivity in the voxel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>emission_function</strong> (<em>callable</em>) – a function defining the emissivity
in (r, ϕ, z) space</li>
<li><strong>grid_samples</strong> (<em>int</em>) – the number of samples of the emissivitiy to use
to calculate the average</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Return float emissivity:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body"><p class="first last">the average emissivity in the voxel cross section</p>
</td>
</tr>
</tbody>
</table>
<p>Note that while the emissivity function is a 3D function, for
Axisymmetric voxels the return value should be independent of
toroidal angle ϕ.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cherab.tools.inversions.voxels.VoxelCollection">
<em class="property">class </em><code class="descclassname">cherab.tools.inversions.voxels.</code><code class="descname">VoxelCollection</code><a class="headerlink" href="#cherab.tools.inversions.voxels.VoxelCollection" title="Permalink to this definition">¶</a></dt>
<dd><p>The base class for collections of voxels.</p>
<p>Used for managing a collection of voxels when calculating a weight
matrix for example.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>count</strong> (<em>float</em>) – The number of voxels in this collection.</li>
<li><strong>total_volume</strong> (<em>float</em>) – The total volume of all voxels.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="cherab.tools.inversions.voxels.VoxelCollection.emissivities_from_function">
<code class="descname">emissivities_from_function</code><a class="headerlink" href="#cherab.tools.inversions.voxels.VoxelCollection.emissivities_from_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an array of sampled emissivities at each voxel location.</p>
<p>Note that the results will be nonsense if you mix an emission function
and VoxelCollection with incompatible symmetries.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>emission_function</strong> (<em>Function3D</em>) – Emission function to sample over.</li>
<li><strong>grid_samples</strong> (<em>int</em>) – Number of emission samples to average over.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">np.ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="cherab.tools.inversions.voxels.VoxelCollection.parent_all_voxels">
<code class="descname">parent_all_voxels</code><a class="headerlink" href="#cherab.tools.inversions.voxels.VoxelCollection.parent_all_voxels" title="Permalink to this definition">¶</a></dt>
<dd><p>Add all voxels in this collection to the scenegraph.</p>
</dd></dl>

<dl class="attribute">
<dt id="cherab.tools.inversions.voxels.VoxelCollection.set_active">
<code class="descname">set_active</code><a class="headerlink" href="#cherab.tools.inversions.voxels.VoxelCollection.set_active" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the ith voxel as an active emitter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>item</strong> – If item is an int, the ith voxel will be configured as an active emitter,
all the others will be turned off. If item is the string ‘all’, all voxels will be
active emitters.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="cherab.tools.inversions.voxels.VoxelCollection.unparent_all_voxels">
<code class="descname">unparent_all_voxels</code><a class="headerlink" href="#cherab.tools.inversions.voxels.VoxelCollection.unparent_all_voxels" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all voxels in this collection from the scenegraph.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cherab.tools.inversions.voxels.ToroidalVoxelGrid">
<em class="property">class </em><code class="descclassname">cherab.tools.inversions.voxels.</code><code class="descname">ToroidalVoxelGrid</code><a class="headerlink" href="#cherab.tools.inversions.voxels.ToroidalVoxelGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>A collection of axis-symmetric toroidal voxels.</p>
<p>This object manages a collection of voxels, where each voxel in the collection
is an AxisymmetricVoxel object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>voxel_coordinates</strong> – An array/list of voxels, where each voxel element
is defined by a list of 2D points.</li>
<li><strong>name</strong> (<em>str</em>) – The name of this voxel collection.</li>
<li><strong>parent</strong> (<em>Node</em>) – The parent scenegraph to which these voxels belong.</li>
<li><strong>transform</strong> (<em>AffineMatrix3D</em>) – The coordinate transformation of this local
coordinate system relative to the scenegraph parent, defaults to the identity
transform.</li>
<li><strong>active</strong> – Selects which voxels are active emitters in the initialised state.
If active is an int, the ith voxel will be configured as an active emitter, all
the others will be turned off. If active is the string ‘all’, all voxels will be
active emitters.</li>
<li><strong>primitive_type</strong> (<em>str</em>) – The geometry type to use for the AxisymmetricVoxel
instances, can be [‘mesh’, ‘csg’]. See their documentation for more information.
Defaults to <cite>primitive_type=’csg’</cite>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="cherab.tools.inversions.voxels.ToroidalVoxelGrid.plot">
<code class="descname">plot</code><a class="headerlink" href="#cherab.tools.inversions.voxels.ToroidalVoxelGrid.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots a voxel grid.</p>
<p>If no voxel data values are provided, the plot is an outline of the grid in the r-z plane. If
voxel values are provided, this method plots the voxel grid coloured by the voxel intensities.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>title</strong> (<em>str</em>) – The title of the plot.</li>
<li><strong>voxel_values</strong> (<em>np.ndarray</em>) – A 1D numpy array with length equal to the number of voxels
in the collection.</li>
<li><strong>ax</strong> – The matplotlib Axes object on which the plot will be made. If None, this function
generates a new plot.</li>
<li><strong>vmin</strong> (<em>float</em>) – The minimum value for the colour map.</li>
<li><strong>vmax</strong> (<em>float</em>) – The maximum value for the colour map.</li>
<li><strong>cmap</strong> – The matplotlib colour map to use for colouring the voxel intensities.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="utility.html" class="btn btn-neutral float-right" title="10.6. Utilities" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="observers.html" class="btn btn-neutral" title="10.4. Observers" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, CHERAB Team.

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1.01',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
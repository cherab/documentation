

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Calculating a Geometry Matrix using the Voxel Framework &mdash; Cherab 1.4.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> Cherab
          

          
          </a>

          
            
            
              <div class="version">
                1.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">Table of Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../welcome.html">1. Welcome</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../licence.html">2. Licence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../governance.html">3. Project Governance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation_and_structure.html">4. Installation and Project Structure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../available_modules.html">5. Available Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../atomic/atomic_data.html">6. Atomic Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../plasmas/plasmas.html">7. Plasmas</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../models/emission_models.html">8. Emission Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../math/math.html">9. Function Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/tools.html">10. Tools</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Demonstrations</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../demonstrations.html">Atomic Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../demonstrations.html#creating-plasmas">Creating Plasmas</a></li>
<li class="toctree-l1"><a class="reference internal" href="../demonstrations.html#surface-radiation-loads">Surface Radiation Loads</a></li>
<li class="toctree-l1"><a class="reference internal" href="../demonstrations.html#active-spectroscopy">Active Spectroscopy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../demonstrations.html#passive-spectroscopy">Passive Spectroscopy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../demonstrations.html#bolometry">Bolometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="../demonstrations.html#geometry-matrices">Geometry Matrices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../demonstrations.html#code-examples-gallery">Code examples gallery</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Cherab</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
      <li>Calculating a Geometry Matrix using the Voxel Framework</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/demonstrations/bolometry/geometry_matrix_from_voxels.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="calculating-a-geometry-matrix-using-the-voxel-framework">
<span id="bolometer-geometry-voxels"></span><h1>Calculating a Geometry Matrix using the Voxel Framework<a class="headerlink" href="#calculating-a-geometry-matrix-using-the-voxel-framework" title="Permalink to this headline">Â¶</a></h1>
<p>In this demonstration, we calculate the geometry matrix for a slightly more complicated
bolometer system, consisting of 3 cameras each of which have 16 foils looking through a
single aperture. For simplicity we discretise the measurement space into toroidally
symmetric voxels of identical rectangular cross section, although it is possible to
have an arbitrary cross section in the voxel framework.</p>
<p>In addition to the geometry matrix, a regularisation operator is generated. This is
needed for regularised tomographic inversions, as shown in the <a class="reference internal" href="inversion_with_voxels.html#bolometer-voxel-inversion"><span class="std std-ref">Inversion with
Voxels</span></a> demo. We use a simple Laplacian operator as the
regularisation operator, which corresponds to isotropic smoothing.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This example demonstrates calculating the geometry matrix for a</span>
<span class="sd">bolometer system using a voxel collection. In this instance the voxel</span>
<span class="sd">collection make up of a regular grid of rectangular voxels, but this is</span>
<span class="sd">not strictly necessary: it just makes deriving a regularisation operator</span>
<span class="sd">for the inversions in other demos a bit easier.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">matplotlib.patches</span> <span class="kn">import</span> <span class="n">Rectangle</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">raysect.core</span> <span class="kn">import</span> <span class="n">Node</span><span class="p">,</span> <span class="n">Point2D</span><span class="p">,</span> <span class="n">Point3D</span><span class="p">,</span> <span class="n">Vector3D</span><span class="p">,</span> <span class="n">rotate_basis</span><span class="p">,</span> <span class="n">rotate_y</span><span class="p">,</span> <span class="n">translate</span>
<span class="kn">from</span> <span class="nn">raysect.core.math.function.float</span> <span class="kn">import</span> <span class="n">Arg2D</span>
<span class="kn">from</span> <span class="nn">raysect.optical</span> <span class="kn">import</span> <span class="n">World</span>
<span class="kn">from</span> <span class="nn">raysect.optical.material</span> <span class="kn">import</span> <span class="n">AbsorbingSurface</span>
<span class="kn">from</span> <span class="nn">raysect.primitive</span> <span class="kn">import</span> <span class="n">Box</span><span class="p">,</span> <span class="n">Cylinder</span><span class="p">,</span> <span class="n">Subtract</span>

<span class="kn">from</span> <span class="nn">cherab.tools.inversions</span> <span class="kn">import</span> <span class="n">ToroidalVoxelGrid</span>
<span class="kn">from</span> <span class="nn">cherab.tools.observers</span> <span class="kn">import</span> <span class="n">BolometerCamera</span><span class="p">,</span> <span class="n">BolometerSlit</span><span class="p">,</span> <span class="n">BolometerFoil</span>


<span class="c1"># Convenient constants</span>
<span class="n">XAXIS</span> <span class="o">=</span> <span class="n">Vector3D</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">YAXIS</span> <span class="o">=</span> <span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">ZAXIS</span> <span class="o">=</span> <span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">ORIGIN</span> <span class="o">=</span> <span class="n">Point3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="c1"># Bolometer geometry</span>
<span class="n">BOX_WIDTH</span> <span class="o">=</span> <span class="mf">0.05</span>
<span class="n">BOX_WIDTH</span> <span class="o">=</span> <span class="mf">0.2</span>
<span class="n">BOX_HEIGHT</span> <span class="o">=</span> <span class="mf">0.07</span>
<span class="n">BOX_DEPTH</span> <span class="o">=</span> <span class="mf">0.2</span>
<span class="n">SLIT_WIDTH</span> <span class="o">=</span> <span class="mf">0.004</span>
<span class="n">SLIT_HEIGHT</span> <span class="o">=</span> <span class="mf">0.005</span>
<span class="n">FOIL_WIDTH</span> <span class="o">=</span> <span class="mf">0.0013</span>
<span class="n">FOIL_HEIGHT</span> <span class="o">=</span> <span class="mf">0.0038</span>
<span class="n">FOIL_CORNER_CURVATURE</span> <span class="o">=</span> <span class="mf">0.0005</span>
<span class="n">SLIT_SENSOR_SEPARATION</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="n">FOIL_SEPARATION</span> <span class="o">=</span> <span class="mf">0.00508</span>  <span class="c1"># 0.2 inch between foils</span>
<span class="n">SENSOR_ANGLES</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">18</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">18</span><span class="p">]</span>

<span class="n">world</span> <span class="o">=</span> <span class="n">World</span><span class="p">()</span>


<span class="c1">########################################################################</span>
<span class="c1"># Make a simple vessel geometry</span>
<span class="c1">########################################################################</span>
<span class="n">centre_column_radius</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">vessel_wall_radius</span> <span class="o">=</span> <span class="mf">3.7</span>
<span class="n">vessel_height</span> <span class="o">=</span> <span class="mf">3.7</span>
<span class="n">vessel</span> <span class="o">=</span> <span class="n">Subtract</span><span class="p">(</span>
    <span class="n">Cylinder</span><span class="p">(</span><span class="n">radius</span><span class="o">=</span><span class="n">vessel_wall_radius</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="n">vessel_height</span><span class="p">),</span>
    <span class="n">Cylinder</span><span class="p">(</span><span class="n">radius</span><span class="o">=</span><span class="n">centre_column_radius</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="n">vessel_height</span><span class="p">),</span>
    <span class="n">material</span><span class="o">=</span><span class="n">AbsorbingSurface</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Vessel&quot;</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">world</span><span class="p">,</span>
<span class="p">)</span>


<span class="c1">########################################################################</span>
<span class="c1"># Build a simple bolometer system</span>
<span class="c1">########################################################################</span>
<span class="k">def</span> <span class="nf">make_bolometer_camera</span><span class="p">():</span>
    <span class="c1"># The camera consists of a box with a rectangular slit and 4 sensors,</span>
    <span class="c1"># each of which has 4 foils.</span>
    <span class="c1"># In its local coordinate system, the camera&#39;s slit is located at the</span>
    <span class="c1"># origin and the sensors below the z=0 plane, looking up towards the slit.</span>
    <span class="n">camera_box</span> <span class="o">=</span> <span class="n">Box</span><span class="p">(</span><span class="n">lower</span><span class="o">=</span><span class="n">Point3D</span><span class="p">(</span><span class="o">-</span><span class="n">BOX_WIDTH</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">BOX_HEIGHT</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">BOX_DEPTH</span><span class="p">),</span>
                     <span class="n">upper</span><span class="o">=</span><span class="n">Point3D</span><span class="p">(</span><span class="n">BOX_WIDTH</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">BOX_HEIGHT</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="c1"># Hollow out the box</span>
    <span class="n">inside_box</span> <span class="o">=</span> <span class="n">Box</span><span class="p">(</span><span class="n">lower</span><span class="o">=</span><span class="n">camera_box</span><span class="o">.</span><span class="n">lower</span> <span class="o">+</span> <span class="n">Vector3D</span><span class="p">(</span><span class="mf">1e-5</span><span class="p">,</span> <span class="mf">1e-5</span><span class="p">,</span> <span class="mf">1e-5</span><span class="p">),</span>
                     <span class="n">upper</span><span class="o">=</span><span class="n">camera_box</span><span class="o">.</span><span class="n">upper</span> <span class="o">-</span> <span class="n">Vector3D</span><span class="p">(</span><span class="mf">1e-5</span><span class="p">,</span> <span class="mf">1e-5</span><span class="p">,</span> <span class="mf">1e-5</span><span class="p">))</span>
    <span class="n">camera_box</span> <span class="o">=</span> <span class="n">Subtract</span><span class="p">(</span><span class="n">camera_box</span><span class="p">,</span> <span class="n">inside_box</span><span class="p">)</span>
    <span class="c1"># The slit is a hole in the box</span>
    <span class="n">aperture</span> <span class="o">=</span> <span class="n">Box</span><span class="p">(</span><span class="n">lower</span><span class="o">=</span><span class="n">Point3D</span><span class="p">(</span><span class="o">-</span><span class="n">SLIT_WIDTH</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">SLIT_HEIGHT</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mf">1e-4</span><span class="p">),</span>
                   <span class="n">upper</span><span class="o">=</span><span class="n">Point3D</span><span class="p">(</span><span class="n">SLIT_WIDTH</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">SLIT_HEIGHT</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">1e-4</span><span class="p">))</span>
    <span class="n">camera_box</span> <span class="o">=</span> <span class="n">Subtract</span><span class="p">(</span><span class="n">camera_box</span><span class="p">,</span> <span class="n">aperture</span><span class="p">)</span>
    <span class="n">camera_box</span><span class="o">.</span><span class="n">material</span> <span class="o">=</span> <span class="n">AbsorbingSurface</span><span class="p">()</span>
    <span class="c1"># Instance of the bolometer camera</span>
    <span class="n">bolometer_camera</span> <span class="o">=</span> <span class="n">BolometerCamera</span><span class="p">(</span><span class="n">camera_geometry</span><span class="o">=</span><span class="n">camera_box</span><span class="p">)</span>
    <span class="c1"># The bolometer slit in this instance just contains targeting information</span>
    <span class="c1"># for the ray tracing, since we have already given our camera a geometry</span>
    <span class="c1"># The slit is defined in the local coordinate system of the camera</span>
    <span class="n">slit</span> <span class="o">=</span> <span class="n">BolometerSlit</span><span class="p">(</span><span class="n">slit_id</span><span class="o">=</span><span class="s2">&quot;Example slit&quot;</span><span class="p">,</span> <span class="n">centre_point</span><span class="o">=</span><span class="n">ORIGIN</span><span class="p">,</span>
                         <span class="n">basis_x</span><span class="o">=</span><span class="n">XAXIS</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="n">SLIT_WIDTH</span><span class="p">,</span> <span class="n">basis_y</span><span class="o">=</span><span class="n">YAXIS</span><span class="p">,</span> <span class="n">dy</span><span class="o">=</span><span class="n">SLIT_HEIGHT</span><span class="p">,</span>
                         <span class="n">parent</span><span class="o">=</span><span class="n">bolometer_camera</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">angle</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">SENSOR_ANGLES</span><span class="p">):</span>
        <span class="c1"># 4 bolometer foils, spaced at equal intervals along the local X axis</span>
        <span class="c1"># The bolometer positions and orientations are given in the local coordinate</span>
        <span class="c1"># system of the camera, just like the slit</span>
        <span class="n">sensor</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Bolometer sensor&quot;</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">bolometer_camera</span><span class="p">,</span>
                      <span class="n">transform</span><span class="o">=</span><span class="n">rotate_y</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span> <span class="o">*</span> <span class="n">translate</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">SLIT_SENSOR_SEPARATION</span><span class="p">))</span>
        <span class="c1"># The foils are shifted relative to the centre of the sensor by -1.5, -0.5, 0.5 and 1.5</span>
        <span class="c1"># times the foil-foil separation</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">shift</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">]):</span>
            <span class="c1"># Note that the foils will be parented to the camera rather than the</span>
            <span class="c1"># sensor, so we need to define their transform relative to the camera</span>
            <span class="n">foil_transform</span> <span class="o">=</span> <span class="n">sensor</span><span class="o">.</span><span class="n">transform</span> <span class="o">*</span> <span class="n">translate</span><span class="p">(</span><span class="n">shift</span> <span class="o">*</span> <span class="n">FOIL_SEPARATION</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">foil</span> <span class="o">=</span> <span class="n">BolometerFoil</span><span class="p">(</span><span class="n">detector_id</span><span class="o">=</span><span class="s2">&quot;Foil </span><span class="si">{}</span><span class="s2"> sensor </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
                                 <span class="n">centre_point</span><span class="o">=</span><span class="n">ORIGIN</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">foil_transform</span><span class="p">),</span>
                                 <span class="n">basis_x</span><span class="o">=</span><span class="n">XAXIS</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">foil_transform</span><span class="p">),</span> <span class="n">dx</span><span class="o">=</span><span class="n">FOIL_WIDTH</span><span class="p">,</span>
                                 <span class="n">basis_y</span><span class="o">=</span><span class="n">YAXIS</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">foil_transform</span><span class="p">),</span> <span class="n">dy</span><span class="o">=</span><span class="n">FOIL_HEIGHT</span><span class="p">,</span>
                                 <span class="n">slit</span><span class="o">=</span><span class="n">slit</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">bolometer_camera</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s2">&quot;Power&quot;</span><span class="p">,</span>
                                 <span class="n">accumulate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">curvature_radius</span><span class="o">=</span><span class="n">FOIL_CORNER_CURVATURE</span><span class="p">)</span>
            <span class="n">bolometer_camera</span><span class="o">.</span><span class="n">add_foil_detector</span><span class="p">(</span><span class="n">foil</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">bolometer_camera</span>


<span class="c1"># Make several cameras distributed around the outside of the vessel</span>
<span class="n">camera_angles</span> <span class="o">=</span> <span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">100</span><span class="p">]</span>
<span class="n">rotation_origin</span> <span class="o">=</span> <span class="n">Point2D</span><span class="p">(</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">)</span>
<span class="n">cameras</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">camera_angle</span> <span class="ow">in</span> <span class="n">camera_angles</span><span class="p">:</span>
    <span class="n">camera</span> <span class="o">=</span> <span class="n">make_bolometer_camera</span><span class="p">()</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">transform</span> <span class="o">=</span> <span class="p">(</span><span class="n">translate</span><span class="p">(</span><span class="n">rotation_origin</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rotation_origin</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
                        <span class="o">*</span> <span class="n">rotate_y</span><span class="p">(</span><span class="n">camera_angle</span><span class="p">)</span>
                        <span class="o">*</span> <span class="n">translate</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span>
                        <span class="o">*</span> <span class="n">rotate_basis</span><span class="p">(</span><span class="o">-</span><span class="n">ZAXIS</span><span class="p">,</span> <span class="n">YAXIS</span><span class="p">)</span>
                        <span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">world</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Angle </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">camera_angle</span><span class="p">)</span>
    <span class="n">cameras</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">camera</span><span class="p">)</span>


<span class="c1">########################################################################</span>
<span class="c1"># Show the lines of sight of all the bolometer channels</span>
<span class="c1">########################################################################</span>
<span class="k">def</span> <span class="nf">_point3d_to_rz</span><span class="p">(</span><span class="n">point</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Point2D</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">point</span><span class="o">.</span><span class="n">y</span><span class="p">),</span> <span class="n">point</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>


<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">all_foils</span> <span class="o">=</span> <span class="p">[</span><span class="n">foil</span> <span class="k">for</span> <span class="n">camera</span> <span class="ow">in</span> <span class="n">cameras</span> <span class="k">for</span> <span class="n">foil</span> <span class="ow">in</span> <span class="n">camera</span><span class="p">]</span>
<span class="k">for</span> <span class="n">foil</span> <span class="ow">in</span> <span class="n">all_foils</span><span class="p">:</span>
    <span class="n">slit_centre</span> <span class="o">=</span> <span class="n">foil</span><span class="o">.</span><span class="n">slit</span><span class="o">.</span><span class="n">centre_point</span>
    <span class="n">slit_centre_rz</span> <span class="o">=</span> <span class="n">_point3d_to_rz</span><span class="p">(</span><span class="n">slit_centre</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">slit_centre_rz</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">slit_centre_rz</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;ko&#39;</span><span class="p">)</span>
    <span class="n">origin</span><span class="p">,</span> <span class="n">hit</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">foil</span><span class="o">.</span><span class="n">trace_sightline</span><span class="p">()</span>
    <span class="n">centre_rz</span> <span class="o">=</span> <span class="n">_point3d_to_rz</span><span class="p">(</span><span class="n">foil</span><span class="o">.</span><span class="n">centre_point</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">centre_rz</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">centre_rz</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;kx&#39;</span><span class="p">)</span>
    <span class="n">origin_rz</span> <span class="o">=</span> <span class="n">_point3d_to_rz</span><span class="p">(</span><span class="n">origin</span><span class="p">)</span>
    <span class="n">hit_rz</span> <span class="o">=</span> <span class="n">_point3d_to_rz</span><span class="p">(</span><span class="n">hit</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">origin_rz</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">hit_rz</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="n">origin_rz</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">hit_rz</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="s1">&#39;k&#39;</span><span class="p">)</span>

<span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">Rectangle</span><span class="p">((</span><span class="n">centre_column_radius</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span>
                       <span class="n">width</span><span class="o">=</span><span class="p">(</span><span class="n">vessel_wall_radius</span> <span class="o">-</span> <span class="n">centre_column_radius</span><span class="p">),</span>
                       <span class="n">height</span><span class="o">=</span><span class="n">vessel_height</span><span class="p">,))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Bolometer camera lines of sight&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">)</span>

<span class="c1">########################################################################</span>
<span class="c1"># Define the region of interest for the inversions</span>
<span class="c1">########################################################################</span>

<span class="c1"># The inversions will be performed on the emission profile used in the</span>
<span class="c1"># radiation_function.py demo, so we&#39;ll trim the voxel grid down to the</span>
<span class="c1"># emitting region</span>
<span class="n">PLASMA_AXIS</span> <span class="o">=</span> <span class="n">Point2D</span><span class="p">(</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">)</span>
<span class="n">LCFS_RADIUS</span> <span class="o">=</span> <span class="mi">1</span>

<span class="c1"># distance of the virtual inner wall from LCFS</span>
<span class="n">WALL_LCFS_OFFSET</span> <span class="o">=</span> <span class="mf">0.1</span>

<span class="c1"># Build a mask, only including cells within the wall</span>
<span class="c1"># We&#39;ll use raysect&#39;s function framework for this</span>
<span class="n">radius_squared</span> <span class="o">=</span> <span class="p">((</span><span class="n">Arg2D</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="n">PLASMA_AXIS</span><span class="o">.</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">Arg2D</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="n">PLASMA_AXIS</span><span class="o">.</span><span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="n">mask</span> <span class="o">=</span> <span class="n">radius_squared</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">WALL_LCFS_OFFSET</span> <span class="o">+</span> <span class="n">LCFS_RADIUS</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>

<span class="c1">########################################################################</span>
<span class="c1"># Produce a voxel grid</span>
<span class="c1">########################################################################</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Producing the voxel grid...&quot;</span><span class="p">)</span>
<span class="c1"># We&#39;ll use a grid of rectangular voxels here, all of which are the same</span>
<span class="c1"># size. Neither the shape nor the uniform size are required for using the</span>
<span class="c1"># voxels, but it makes this example a bit simpler.</span>

<span class="c1"># Define the centres of each voxel, as an (nx, ny, 2) array</span>
<span class="n">nx</span> <span class="o">=</span> <span class="mi">40</span>
<span class="n">ny</span> <span class="o">=</span> <span class="mi">60</span>
<span class="n">cell_centres</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">nx</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">ny</span><span class="p">))</span>
<span class="n">cell_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">nx</span><span class="p">)</span>
<span class="n">cell_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span>
<span class="n">cell_r_grid</span><span class="p">,</span> <span class="n">cell_z_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="n">cell_r</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">cell_z</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:])</span>
<span class="n">cell_centres</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">cell_r_grid</span><span class="p">,</span> <span class="n">cell_z_grid</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># (nx, ny, 2) array</span>
<span class="n">cell_dx</span> <span class="o">=</span> <span class="n">cell_centres</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">cell_centres</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">cell_dy</span> <span class="o">=</span> <span class="n">cell_centres</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">cell_centres</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

<span class="c1"># Define the positions of the vertices of the voxels, as an (nx, ny, 4, 2) array</span>
<span class="n">cell_vertex_displacements</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">cell_dx</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">cell_dy</span><span class="p">,</span>
                                        <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">cell_dx</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">cell_dy</span><span class="p">,</span>
                                        <span class="mf">0.5</span> <span class="o">*</span> <span class="n">cell_dx</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">cell_dy</span><span class="p">,</span>
                                        <span class="mf">0.5</span> <span class="o">*</span> <span class="n">cell_dx</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">cell_dy</span><span class="p">])</span>
<span class="n">all_cell_vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">cell_centres</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">cell_vertex_displacements</span>

<span class="c1"># Produce a (ncells, nvertices, 2) array of coordinates to initialise the</span>
<span class="c1"># ToroidalVoxelCollection. Here, ncells = number of cells inside mask,</span>
<span class="c1"># nvertices = 4. The ToroidalVoxelGrid expects a flat list of (nvertices, 2)</span>
<span class="c1"># arrays to define voxels, since there is no implicit assumption that the voxels</span>
<span class="c1"># lie on a grid.</span>
<span class="n">enclosed_cells</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">grid_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="n">grid_index_2D_to_1D_map</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">grid_index_1D_to_2D_map</span> <span class="o">=</span> <span class="p">{}</span>

<span class="c1"># Identify the cells that are enclosed by the polygon,</span>
<span class="c1"># simultaneously write out grid mask and grid map.</span>
<span class="n">unwrapped_cell_index</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">iy</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny</span><span class="p">):</span>
        <span class="c1"># p1, p2, p3, p4 = cell_vertices[ix][iy]</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="n">all_cell_vertices</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span>

        <span class="c1"># if any points are inside the polygon, retain this cell</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">mask</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">):</span>
            <span class="n">grid_mask</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># We&#39;ll need these maps for generating the regularisation operator</span>
            <span class="n">grid_index_2D_to_1D_map</span><span class="p">[(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">)]</span> <span class="o">=</span> <span class="n">unwrapped_cell_index</span>
            <span class="n">grid_index_1D_to_2D_map</span><span class="p">[</span><span class="n">unwrapped_cell_index</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">)</span>
            <span class="n">enclosed_cells</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
            <span class="n">unwrapped_cell_index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">grid_mask</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>


<span class="n">num_cells</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">enclosed_cells</span><span class="p">)</span>


<span class="n">voxel_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">num_cells</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>  <span class="c1"># (number of cells, 4 coordinates, x and y values)</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">enclosed_cells</span><span class="p">):</span>
    <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="p">,</span> <span class="n">p4</span> <span class="o">=</span> <span class="n">row</span>
    <span class="n">voxel_data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">p1</span>
    <span class="n">voxel_data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">p2</span>
    <span class="n">voxel_data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">p3</span>
    <span class="n">voxel_data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">p4</span>

<span class="n">voxel_grid</span> <span class="o">=</span> <span class="n">ToroidalVoxelGrid</span><span class="p">(</span><span class="n">voxel_data</span><span class="p">)</span>


<span class="c1">########################################################################</span>
<span class="c1"># Produce a regularisation operator for inversions</span>
<span class="c1">########################################################################</span>
<span class="c1"># We&#39;ll use simple isotropic smoothing here, in which case an ND second</span>
<span class="c1"># derivative operator (the laplacian operator) is appropriate</span>
<span class="n">grid_laplacian</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_cells</span><span class="p">,</span> <span class="n">num_cells</span><span class="p">))</span>

<span class="k">for</span> <span class="n">ith_cell</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_cells</span><span class="p">):</span>

    <span class="c1"># get the 2D mesh coordinates of this cell</span>
    <span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="o">=</span> <span class="n">grid_index_1D_to_2D_map</span><span class="p">[</span><span class="n">ith_cell</span><span class="p">]</span>

    <span class="n">neighbours</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">grid_index_2D_to_1D_map</span><span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span>  <span class="c1"># neighbour 1</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">grid_laplacian</span><span class="p">[</span><span class="n">ith_cell</span><span class="p">,</span> <span class="n">n1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">neighbours</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">n2</span> <span class="o">=</span> <span class="n">grid_index_2D_to_1D_map</span><span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># neighbour 2</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">grid_laplacian</span><span class="p">[</span><span class="n">ith_cell</span><span class="p">,</span> <span class="n">n2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">neighbours</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">n3</span> <span class="o">=</span> <span class="n">grid_index_2D_to_1D_map</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># neighbour 3</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">grid_laplacian</span><span class="p">[</span><span class="n">ith_cell</span><span class="p">,</span> <span class="n">n3</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">neighbours</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">n4</span> <span class="o">=</span> <span class="n">grid_index_2D_to_1D_map</span><span class="p">[</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># neighbour 4</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">grid_laplacian</span><span class="p">[</span><span class="n">ith_cell</span><span class="p">,</span> <span class="n">n4</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">neighbours</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">n5</span> <span class="o">=</span> <span class="n">grid_index_2D_to_1D_map</span><span class="p">[</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span>  <span class="c1"># neighbour 5</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">grid_laplacian</span><span class="p">[</span><span class="n">ith_cell</span><span class="p">,</span> <span class="n">n5</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">neighbours</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">n6</span> <span class="o">=</span> <span class="n">grid_index_2D_to_1D_map</span><span class="p">[</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># neighbour 6</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">grid_laplacian</span><span class="p">[</span><span class="n">ith_cell</span><span class="p">,</span> <span class="n">n6</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">neighbours</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">n7</span> <span class="o">=</span> <span class="n">grid_index_2D_to_1D_map</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># neighbour 7</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">grid_laplacian</span><span class="p">[</span><span class="n">ith_cell</span><span class="p">,</span> <span class="n">n7</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">neighbours</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">n8</span> <span class="o">=</span> <span class="n">grid_index_2D_to_1D_map</span><span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># neighbour 8</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">grid_laplacian</span><span class="p">[</span><span class="n">ith_cell</span><span class="p">,</span> <span class="n">n8</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">neighbours</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">grid_laplacian</span><span class="p">[</span><span class="n">ith_cell</span><span class="p">,</span> <span class="n">ith_cell</span><span class="p">]</span> <span class="o">=</span> <span class="n">neighbours</span>


<span class="c1">########################################################################</span>
<span class="c1"># Calculate the geometry matrix for the grid</span>
<span class="c1">########################################################################</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Calculating the geometry matrix...&quot;</span><span class="p">)</span>
<span class="c1"># The voxel grid must be in the same world as the bolometers</span>
<span class="n">voxel_grid</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">world</span>

<span class="n">sensitivity_matrix</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">camera</span> <span class="ow">in</span> <span class="n">cameras</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">foil</span> <span class="ow">in</span> <span class="n">camera</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Calculating sensitivity for </span><span class="si">{}</span><span class="s2">...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">foil</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
        <span class="n">sensitivity_matrix</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">foil</span><span class="o">.</span><span class="n">calculate_sensitivity</span><span class="p">(</span><span class="n">voxel_grid</span><span class="p">))</span>
<span class="n">sensitivity_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">sensitivity_matrix</span><span class="p">)</span>

<span class="c1"># Plot the sensitivity matrix, summed over all foils</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">voxel_grid</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Total sensitivity [mÂ³sr]&quot;</span><span class="p">,</span>
                <span class="n">voxel_values</span><span class="o">=</span><span class="n">sensitivity_matrix</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">)</span>

<span class="c1"># Save the voxel grid information and the geometry matrix for use in other demos</span>
<span class="n">voxel_grid_data</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;voxel_data&#39;</span><span class="p">:</span> <span class="n">voxel_data</span><span class="p">,</span> <span class="s1">&#39;laplacian&#39;</span><span class="p">:</span> <span class="n">grid_laplacian</span><span class="p">,</span>
                   <span class="s1">&#39;grid_index_1D_to_2D_map&#39;</span><span class="p">:</span> <span class="n">grid_index_1D_to_2D_map</span><span class="p">,</span>
                   <span class="s1">&#39;grid_index_2D_to_1D_map&#39;</span><span class="p">:</span> <span class="n">grid_index_2D_to_1D_map</span><span class="p">,</span>
                   <span class="s1">&#39;sensitivity_matrix&#39;</span><span class="p">:</span> <span class="n">sensitivity_matrix</span><span class="p">}</span>

<span class="n">script_dir</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">script_dir</span> <span class="o">/</span> <span class="s2">&quot;voxel_grid_data.pickle&quot;</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">voxel_grid_data</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="figure align-center" id="id1">
<img alt="../../_images/bolometer_inversion_lines_of_sight.svg" src="../../_images/bolometer_inversion_lines_of_sight.svg" /><p class="caption"><span class="caption-text"><strong>Caption</strong> The lines of sight of the 48 foils in 3 bolometer cameras, used to
generate the sensitivity matrix.</span><a class="headerlink" href="#id1" title="Permalink to this image">Â¶</a></p>
</div>
<div class="figure align-center" id="id2">
<img alt="../../_images/bolometer_voxel_sensitivities.png" src="../../_images/bolometer_voxel_sensitivities.png" />
<p class="caption"><span class="caption-text"><strong>Caption</strong> The result of summing the sensitivty of all foils, for each voxel in the
voxel collection.</span><a class="headerlink" href="#id2" title="Permalink to this image">Â¶</a></p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2022, Cherab Team

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    

  

  <script type="text/javascript" src="../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
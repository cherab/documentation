

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Performing Inversions of Bolometer Measurements Using the Voxel Framework &mdash; Cherab 1.5.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/tabs.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> Cherab
          

          
          </a>

          
            
            
              <div class="version">
                1.5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">Table of Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../welcome.html">1. Welcome</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../licence.html">2. Licence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../governance.html">3. Project Governance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation_and_structure.html">4. Installation and Project Structure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../available_modules.html">5. Available Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../atomic/atomic_data.html">6. Atomic Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../plasmas/plasmas.html">7. Plasmas</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../models/emission_models.html">8. Emission Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../math/math.html">9. Function Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/tools.html">10. Tools</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Demonstrations</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../demonstrations.html">Atomic Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../demonstrations.html#creating-plasmas">Creating Plasmas</a></li>
<li class="toctree-l1"><a class="reference internal" href="../demonstrations.html#surface-radiation-loads">Surface Radiation Loads</a></li>
<li class="toctree-l1"><a class="reference internal" href="../demonstrations.html#active-spectroscopy">Active Spectroscopy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../demonstrations.html#passive-spectroscopy">Passive Spectroscopy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../demonstrations.html#bolometry">Bolometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="../demonstrations.html#geometry-matrices">Geometry Matrices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../demonstrations.html#code-examples-gallery">Code examples gallery</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Cherab</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
      <li>Performing Inversions of Bolometer Measurements Using the Voxel Framework</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/demonstrations/bolometry/inversion_with_voxels.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="performing-inversions-of-bolometer-measurements-using-the-voxel-framework">
<span id="bolometer-voxel-inversion"></span><h1>Performing Inversions of Bolometer Measurements Using the Voxel Framework<a class="headerlink" href="#performing-inversions-of-bolometer-measurements-using-the-voxel-framework" title="Permalink to this heading">¶</a></h1>
<p>In this demonstration, we take the geometry matrix and regularisation operator
calculated in the <a class="reference internal" href="geometry_matrix_from_voxels.html#bolometer-geometry-voxels"><span class="std std-ref">Geometry Matrix Calculation Using Voxels</span></a> demonstration and use them to perform an inversion of
simulated bolometer measurements from a defined emissivity profile. The emission source
is the same one used in the <a class="reference internal" href="../radiation_loads/radiation_function.html#radiation-function"><span class="std std-ref">Defining A Radiation Function</span></a>
demo.</p>
<p>The bolometer system geometry is necessarily the same as that used to calculate the
geometry matrix. To perform the inversion we use the regularised NNLS routine, with the
voxel grid’s Laplacian operator as the regularisation matrix. The <cite>alpha</cite> parameter
which controls the regularisation was chosen simply by trying different values until the
result looked reasonable. Of course, once the measurement vector, geometry matrix and
regularisation operator have been calculated then any matrix inversion algorithm can be
used to calculate the emissivity profile: we are showcasing one of Cherab’s built-in
routines here for convenience.</p>
<p>We have deliberately calculated the measurement vector here by calling the <cite>observe</cite>
method of <code class="xref py py-class docutils literal notranslate"><span class="pre">BolometerCamera</span></code>, as this produces measurements independent of the
voxel grid. If many emission profiles are being inverted for the same bolometer and
voxel grid geometries, it would be substantially faster to sample the emission
function on the voxel grid and then multiply this by the sensitivity matrix (this is
done in this demo script to produce the plot of the phantom).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This example demonstrates using a grid of voxels to invert bolometer</span>
<span class="sd">measurements and produce a 2D emissivity profile. The bolometer</span>
<span class="sd">measurements are provided by observations of a radiating plasma, with</span>
<span class="sd">the radiation defined by a 2D function. The inverted emissivity profile</span>
<span class="sd">is compared with the original phantom to show the quality of the</span>
<span class="sd">inversion.</span>

<span class="sd">The bolometer and radiating emitter are produced in the same way as the</span>
<span class="sd">`observe_radiation_function.py` demo. We use a simplified cylindrical</span>
<span class="sd">geometry and the same radiation function as in the radiation_function.py</span>
<span class="sd">demo.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">raysect.core</span> <span class="kn">import</span> <span class="n">Node</span><span class="p">,</span> <span class="n">Point2D</span><span class="p">,</span> <span class="n">Point3D</span><span class="p">,</span> <span class="n">Vector3D</span><span class="p">,</span> <span class="n">rotate_basis</span><span class="p">,</span> <span class="n">rotate_y</span><span class="p">,</span> <span class="n">translate</span>
<span class="kn">from</span> <span class="nn">raysect.optical</span> <span class="kn">import</span> <span class="n">World</span>
<span class="kn">from</span> <span class="nn">raysect.optical.material</span> <span class="kn">import</span> <span class="n">AbsorbingSurface</span><span class="p">,</span> <span class="n">VolumeTransform</span>
<span class="kn">from</span> <span class="nn">raysect.primitive</span> <span class="kn">import</span> <span class="n">Box</span><span class="p">,</span> <span class="n">Cylinder</span><span class="p">,</span> <span class="n">Subtract</span>

<span class="kn">from</span> <span class="nn">cherab.core.math</span> <span class="kn">import</span> <span class="n">AxisymmetricMapper</span>
<span class="kn">from</span> <span class="nn">cherab.tools.emitters</span> <span class="kn">import</span> <span class="n">RadiationFunction</span>
<span class="kn">from</span> <span class="nn">cherab.tools.inversions</span> <span class="kn">import</span> <span class="n">ToroidalVoxelGrid</span><span class="p">,</span> <span class="n">invert_regularised_nnls</span>
<span class="kn">from</span> <span class="nn">cherab.tools.observers</span> <span class="kn">import</span> <span class="n">BolometerCamera</span><span class="p">,</span> <span class="n">BolometerSlit</span><span class="p">,</span> <span class="n">BolometerFoil</span>


<span class="c1"># Convenient constants</span>
<span class="n">XAXIS</span> <span class="o">=</span> <span class="n">Vector3D</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">YAXIS</span> <span class="o">=</span> <span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">ZAXIS</span> <span class="o">=</span> <span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">ORIGIN</span> <span class="o">=</span> <span class="n">Point3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="c1"># Bolometer geometry: same as the demo which generates the geometry matrix</span>
<span class="n">BOX_WIDTH</span> <span class="o">=</span> <span class="mf">0.05</span>
<span class="n">BOX_WIDTH</span> <span class="o">=</span> <span class="mf">0.2</span>
<span class="n">BOX_HEIGHT</span> <span class="o">=</span> <span class="mf">0.07</span>
<span class="n">BOX_DEPTH</span> <span class="o">=</span> <span class="mf">0.2</span>
<span class="n">SLIT_WIDTH</span> <span class="o">=</span> <span class="mf">0.004</span>
<span class="n">SLIT_HEIGHT</span> <span class="o">=</span> <span class="mf">0.005</span>
<span class="n">FOIL_WIDTH</span> <span class="o">=</span> <span class="mf">0.0013</span>
<span class="n">FOIL_HEIGHT</span> <span class="o">=</span> <span class="mf">0.0038</span>
<span class="n">FOIL_CORNER_CURVATURE</span> <span class="o">=</span> <span class="mf">0.0005</span>
<span class="n">SLIT_SENSOR_SEPARATION</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="n">FOIL_SEPARATION</span> <span class="o">=</span> <span class="mf">0.00508</span>  <span class="c1"># 0.2 inch between foils</span>
<span class="n">SENSOR_ANGLES</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">18</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">18</span><span class="p">]</span>

<span class="n">world</span> <span class="o">=</span> <span class="n">World</span><span class="p">()</span>


<span class="c1">################################################################################</span>
<span class="c1"># Make a simple vessel geometry</span>
<span class="c1">################################################################################</span>
<span class="n">centre_column_radius</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">vessel_wall_radius</span> <span class="o">=</span> <span class="mf">3.7</span>
<span class="n">vessel_height</span> <span class="o">=</span> <span class="mf">3.7</span>
<span class="n">vessel</span> <span class="o">=</span> <span class="n">Subtract</span><span class="p">(</span>
    <span class="n">Cylinder</span><span class="p">(</span><span class="n">radius</span><span class="o">=</span><span class="n">vessel_wall_radius</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="n">vessel_height</span><span class="p">),</span>
    <span class="n">Cylinder</span><span class="p">(</span><span class="n">radius</span><span class="o">=</span><span class="n">centre_column_radius</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="n">vessel_height</span><span class="p">),</span>
    <span class="n">material</span><span class="o">=</span><span class="n">AbsorbingSurface</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Vessel&quot;</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">world</span><span class="p">,</span>
<span class="p">)</span>


<span class="c1">################################################################################</span>
<span class="c1"># Build a simple bolometer system</span>
<span class="c1">################################################################################</span>
<span class="k">def</span> <span class="nf">make_bolometer_camera</span><span class="p">():</span>
    <span class="c1"># The camera consists of a box with a rectangular slit and 4 sensors, each</span>
    <span class="c1"># of which has 4 foils.</span>
    <span class="c1"># In its local coordinate system, the camera&#39;s slit is located at the</span>
    <span class="c1"># origin and the sensors below the z=0 plane, looking up towards the slit.</span>
    <span class="n">camera_box</span> <span class="o">=</span> <span class="n">Box</span><span class="p">(</span><span class="n">lower</span><span class="o">=</span><span class="n">Point3D</span><span class="p">(</span><span class="o">-</span><span class="n">BOX_WIDTH</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">BOX_HEIGHT</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">BOX_DEPTH</span><span class="p">),</span>
                     <span class="n">upper</span><span class="o">=</span><span class="n">Point3D</span><span class="p">(</span><span class="n">BOX_WIDTH</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">BOX_HEIGHT</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="c1"># Hollow out the box</span>
    <span class="n">inside_box</span> <span class="o">=</span> <span class="n">Box</span><span class="p">(</span><span class="n">lower</span><span class="o">=</span><span class="n">camera_box</span><span class="o">.</span><span class="n">lower</span> <span class="o">+</span> <span class="n">Vector3D</span><span class="p">(</span><span class="mf">1e-5</span><span class="p">,</span> <span class="mf">1e-5</span><span class="p">,</span> <span class="mf">1e-5</span><span class="p">),</span>
                     <span class="n">upper</span><span class="o">=</span><span class="n">camera_box</span><span class="o">.</span><span class="n">upper</span> <span class="o">-</span> <span class="n">Vector3D</span><span class="p">(</span><span class="mf">1e-5</span><span class="p">,</span> <span class="mf">1e-5</span><span class="p">,</span> <span class="mf">1e-5</span><span class="p">))</span>
    <span class="n">camera_box</span> <span class="o">=</span> <span class="n">Subtract</span><span class="p">(</span><span class="n">camera_box</span><span class="p">,</span> <span class="n">inside_box</span><span class="p">)</span>
    <span class="c1"># The slit is a hole in the box</span>
    <span class="n">aperture</span> <span class="o">=</span> <span class="n">Box</span><span class="p">(</span><span class="n">lower</span><span class="o">=</span><span class="n">Point3D</span><span class="p">(</span><span class="o">-</span><span class="n">SLIT_WIDTH</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">SLIT_HEIGHT</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mf">1e-4</span><span class="p">),</span>
                   <span class="n">upper</span><span class="o">=</span><span class="n">Point3D</span><span class="p">(</span><span class="n">SLIT_WIDTH</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">SLIT_HEIGHT</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">1e-4</span><span class="p">))</span>
    <span class="n">camera_box</span> <span class="o">=</span> <span class="n">Subtract</span><span class="p">(</span><span class="n">camera_box</span><span class="p">,</span> <span class="n">aperture</span><span class="p">)</span>
    <span class="n">camera_box</span><span class="o">.</span><span class="n">material</span> <span class="o">=</span> <span class="n">AbsorbingSurface</span><span class="p">()</span>
    <span class="c1"># Instance of the bolometer camera</span>
    <span class="n">bolometer_camera</span> <span class="o">=</span> <span class="n">BolometerCamera</span><span class="p">(</span><span class="n">camera_geometry</span><span class="o">=</span><span class="n">camera_box</span><span class="p">)</span>
    <span class="c1"># The bolometer slit in this instance just contains targeting information</span>
    <span class="c1"># for the ray tracing, since we have already given our camera a geometry</span>
    <span class="c1"># The slit is defined in the local coordinate system of the camera</span>
    <span class="n">slit</span> <span class="o">=</span> <span class="n">BolometerSlit</span><span class="p">(</span><span class="n">slit_id</span><span class="o">=</span><span class="s2">&quot;Example slit&quot;</span><span class="p">,</span> <span class="n">centre_point</span><span class="o">=</span><span class="n">ORIGIN</span><span class="p">,</span>
                         <span class="n">basis_x</span><span class="o">=</span><span class="n">XAXIS</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="n">SLIT_WIDTH</span><span class="p">,</span> <span class="n">basis_y</span><span class="o">=</span><span class="n">YAXIS</span><span class="p">,</span> <span class="n">dy</span><span class="o">=</span><span class="n">SLIT_HEIGHT</span><span class="p">,</span>
                         <span class="n">parent</span><span class="o">=</span><span class="n">bolometer_camera</span><span class="p">,</span> <span class="n">csg_aperture</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">angle</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">SENSOR_ANGLES</span><span class="p">):</span>
        <span class="c1"># 4 bolometer foils, spaced at equal intervals along the local X axis</span>
        <span class="c1"># The bolometer positions and orientations are given in the local coordinate</span>
        <span class="c1"># system of the camera, just like the slit</span>
        <span class="n">sensor</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Bolometer sensor&quot;</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">bolometer_camera</span><span class="p">,</span>
                      <span class="n">transform</span><span class="o">=</span><span class="n">rotate_y</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span> <span class="o">*</span> <span class="n">translate</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">SLIT_SENSOR_SEPARATION</span><span class="p">))</span>
        <span class="c1"># The foils are shifted relative to the centre of the sensor by -1.5, -0.5, 0.5 and 1.5</span>
        <span class="c1"># times the foil-foil separation</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">shift</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">]):</span>
            <span class="n">foil_transform</span> <span class="o">=</span> <span class="n">sensor</span><span class="o">.</span><span class="n">transform</span> <span class="o">*</span> <span class="n">translate</span><span class="p">(</span><span class="n">shift</span> <span class="o">*</span> <span class="n">FOIL_SEPARATION</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">foil</span> <span class="o">=</span> <span class="n">BolometerFoil</span><span class="p">(</span><span class="n">detector_id</span><span class="o">=</span><span class="s2">&quot;Foil </span><span class="si">{}</span><span class="s2"> sensor </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
                                 <span class="n">centre_point</span><span class="o">=</span><span class="n">ORIGIN</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">foil_transform</span><span class="p">),</span>
                                 <span class="n">basis_x</span><span class="o">=</span><span class="n">XAXIS</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">foil_transform</span><span class="p">),</span> <span class="n">dx</span><span class="o">=</span><span class="n">FOIL_WIDTH</span><span class="p">,</span>
                                 <span class="n">basis_y</span><span class="o">=</span><span class="n">YAXIS</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">foil_transform</span><span class="p">),</span> <span class="n">dy</span><span class="o">=</span><span class="n">FOIL_HEIGHT</span><span class="p">,</span>
                                 <span class="n">slit</span><span class="o">=</span><span class="n">slit</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">bolometer_camera</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s2">&quot;Power&quot;</span><span class="p">,</span>
                                 <span class="n">accumulate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">curvature_radius</span><span class="o">=</span><span class="n">FOIL_CORNER_CURVATURE</span><span class="p">)</span>
            <span class="n">bolometer_camera</span><span class="o">.</span><span class="n">add_foil_detector</span><span class="p">(</span><span class="n">foil</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">bolometer_camera</span>


<span class="c1"># Make several cameras distributed around the outside of the vessel</span>
<span class="n">camera_angles</span> <span class="o">=</span> <span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">100</span><span class="p">]</span>
<span class="n">rotation_origin</span> <span class="o">=</span> <span class="n">Point2D</span><span class="p">(</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">)</span>
<span class="n">cameras</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">camera_angle</span> <span class="ow">in</span> <span class="n">camera_angles</span><span class="p">:</span>
    <span class="n">camera</span> <span class="o">=</span> <span class="n">make_bolometer_camera</span><span class="p">()</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">transform</span> <span class="o">=</span> <span class="p">(</span><span class="n">translate</span><span class="p">(</span><span class="n">rotation_origin</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rotation_origin</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
                        <span class="o">*</span> <span class="n">rotate_y</span><span class="p">(</span><span class="n">camera_angle</span><span class="p">)</span>
                        <span class="o">*</span> <span class="n">translate</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span>
                        <span class="o">*</span> <span class="n">rotate_basis</span><span class="p">(</span><span class="o">-</span><span class="n">ZAXIS</span><span class="p">,</span> <span class="n">YAXIS</span><span class="p">)</span>
                        <span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">world</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Angle </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">camera_angle</span><span class="p">)</span>
    <span class="n">cameras</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">camera</span><span class="p">)</span>


<span class="c1">################################################################################</span>
<span class="c1"># Produce a simple radiating plasma.</span>
<span class="c1">################################################################################</span>

<span class="c1"># This is the same emission profile used in the radiation_function.py demo,</span>
<span class="c1"># but scaled down by 1e6 to make the units on the plots cleaner</span>
<span class="n">PLASMA_AXIS</span> <span class="o">=</span> <span class="n">Point2D</span><span class="p">(</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">)</span>
<span class="n">LCFS_RADIUS</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">RING_RADIUS</span> <span class="o">=</span> <span class="mf">0.5</span>

<span class="n">RADIATION_PEAK</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">CENTRE_PEAK_WIDTH</span> <span class="o">=</span> <span class="mf">0.05</span>
<span class="n">RING_WIDTH</span> <span class="o">=</span> <span class="mf">0.025</span>

<span class="c1"># distance of wall from LCFS</span>
<span class="n">WALL_LCFS_OFFSET</span> <span class="o">=</span> <span class="mf">0.1</span>

<span class="n">CYLINDER_RADIUS</span> <span class="o">=</span> <span class="n">PLASMA_AXIS</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">LCFS_RADIUS</span> <span class="o">+</span> <span class="n">WALL_LCFS_OFFSET</span> <span class="o">*</span> <span class="mf">1.1</span>
<span class="n">CYLINDER_HEIGHT</span> <span class="o">=</span> <span class="p">(</span><span class="n">LCFS_RADIUS</span> <span class="o">+</span> <span class="n">WALL_LCFS_OFFSET</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>


<span class="k">def</span> <span class="nf">emission_function_2d</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>

    <span class="n">sample_point</span> <span class="o">=</span> <span class="n">Point2D</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="n">direction</span> <span class="o">=</span> <span class="n">PLASMA_AXIS</span><span class="o">.</span><span class="n">vector_to</span><span class="p">(</span><span class="n">sample_point</span><span class="p">)</span>
    <span class="n">bearing</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">direction</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">direction</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># calculate radius of coordinate from magnetic axis</span>
    <span class="n">radius_from_axis</span> <span class="o">=</span> <span class="n">direction</span><span class="o">.</span><span class="n">length</span>
    <span class="n">closest_ring_point</span> <span class="o">=</span> <span class="n">PLASMA_AXIS</span> <span class="o">+</span> <span class="p">(</span><span class="n">direction</span><span class="o">.</span><span class="n">normalise</span><span class="p">()</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>
    <span class="n">radius_from_ring</span> <span class="o">=</span> <span class="n">sample_point</span><span class="o">.</span><span class="n">distance_to</span><span class="p">(</span><span class="n">closest_ring_point</span><span class="p">)</span>

    <span class="c1"># evaluate pedestal-&gt; core function</span>
    <span class="k">if</span> <span class="n">radius_from_axis</span> <span class="o">&lt;=</span> <span class="n">LCFS_RADIUS</span><span class="p">:</span>

        <span class="n">central_radiatior</span> <span class="o">=</span> <span class="n">RADIATION_PEAK</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">radius_from_axis</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">CENTRE_PEAK_WIDTH</span><span class="p">)</span>

        <span class="n">ring_radiator</span> <span class="o">=</span> <span class="p">(</span><span class="n">RADIATION_PEAK</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">bearing</span><span class="p">)</span>
                         <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">radius_from_ring</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">RING_WIDTH</span><span class="p">))</span>
        <span class="n">ring_radiator</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ring_radiator</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">central_radiatior</span> <span class="o">+</span> <span class="n">ring_radiator</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>


<span class="n">emitter</span> <span class="o">=</span> <span class="n">Cylinder</span><span class="p">(</span><span class="n">radius</span><span class="o">=</span><span class="n">CYLINDER_RADIUS</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="n">CYLINDER_HEIGHT</span><span class="p">,</span>
                   <span class="n">transform</span><span class="o">=</span><span class="n">translate</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="n">emission_function_3d</span> <span class="o">=</span> <span class="n">AxisymmetricMapper</span><span class="p">(</span><span class="n">emission_function_2d</span><span class="p">)</span>
<span class="n">emitting_material</span> <span class="o">=</span> <span class="n">VolumeTransform</span><span class="p">(</span><span class="n">RadiationFunction</span><span class="p">(</span><span class="n">emission_function_3d</span><span class="p">),</span>
                                    <span class="n">transform</span><span class="o">=</span><span class="n">emitter</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">inverse</span><span class="p">())</span>
<span class="n">emitter</span><span class="o">.</span><span class="n">material</span> <span class="o">=</span> <span class="n">emitting_material</span>
<span class="n">emitter</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">world</span>

<span class="c1">################################################################################</span>
<span class="c1"># Measure the radiation with the bolometers</span>
<span class="c1">################################################################################</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Measuring the radiation with the bolometers...&quot;</span><span class="p">)</span>
<span class="n">observations</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">camera</span> <span class="ow">in</span> <span class="n">cameras</span><span class="p">:</span>
    <span class="n">observations</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">camera</span><span class="o">.</span><span class="n">observe</span><span class="p">())</span>
<span class="n">observations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">observations</span><span class="p">)</span>


<span class="c1">################################################################################</span>
<span class="c1"># Load the geometry data required for the inversion</span>
<span class="c1">################################################################################</span>
<span class="n">script_dir</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span>
<span class="k">try</span><span class="p">:</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">script_dir</span> <span class="o">/</span> <span class="s2">&quot;voxel_grid_data.pickle&quot;</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">grid_data</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">FileNotFoundError</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
        <span class="s2">&quot;Geometry data not found: please run the &quot;</span>
        <span class="s2">&quot;geometry_matrix_with_voxels.py demo first.&quot;</span>
    <span class="p">)</span>

<span class="n">voxel_grid</span> <span class="o">=</span> <span class="n">ToroidalVoxelGrid</span><span class="p">(</span><span class="n">grid_data</span><span class="p">[</span><span class="s1">&#39;voxel_data&#39;</span><span class="p">])</span>
<span class="n">grid_laplacian</span> <span class="o">=</span> <span class="n">grid_data</span><span class="p">[</span><span class="s1">&#39;laplacian&#39;</span><span class="p">]</span>
<span class="n">sensitivity_matrix</span> <span class="o">=</span> <span class="n">grid_data</span><span class="p">[</span><span class="s1">&#39;sensitivity_matrix&#39;</span><span class="p">]</span>

<span class="c1"># The sensitivity matrix has units of [m3sr] when the units used to calculate</span>
<span class="c1"># the sensitivity in BolometerFoil.calculate_sensitivity are &quot;Power&quot;.  The</span>
<span class="c1"># radiation function above defines an isotropic emissivity with units of [Wm-3],</span>
<span class="c1"># so we need to divide the sensitivity matrix by 4pi sr to use with power</span>
<span class="c1"># measurements in [W].</span>
<span class="n">sensitivity_matrix</span> <span class="o">/=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>

<span class="c1">################################################################################</span>
<span class="c1"># Perform the inversion</span>
<span class="c1">################################################################################</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Performing inversion...&quot;</span><span class="p">)</span>
<span class="c1"># We&#39;ll use a regularised NNLS inversion here: experience shows it performs</span>
<span class="c1"># better than SART for bolometry systems with relatively low numbers of</span>
<span class="c1"># foils (though it does perform well for imaging cameras with high resolution).</span>

<span class="c1"># Apply a large penalty for placing radiation where there is no bolometer</span>
<span class="c1"># coverage, else the algorithm can put radiation there without affecting the</span>
<span class="c1"># measurements</span>
<span class="n">grid_laplacian</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">sensitivity_matrix</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">1e10</span>

<span class="n">inverted_emission</span><span class="p">,</span> <span class="n">residual_norm</span> <span class="o">=</span> <span class="n">invert_regularised_nnls</span><span class="p">(</span>
    <span class="n">sensitivity_matrix</span><span class="p">,</span> <span class="n">observations</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">1e-11</span><span class="p">,</span> <span class="n">tikhonov_matrix</span><span class="o">=</span><span class="n">grid_laplacian</span>
<span class="p">)</span>

<span class="c1">################################################################################</span>
<span class="c1"># Plot the emissivity profile and the inverted profile</span>
<span class="c1">################################################################################</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Plotting results...&quot;</span><span class="p">)</span>
<span class="n">phantom_samples</span> <span class="o">=</span> <span class="n">voxel_grid</span><span class="o">.</span><span class="n">emissivities_from_function</span><span class="p">(</span><span class="n">emission_function_3d</span><span class="p">)</span>
<span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">voxel_grid</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax1</span><span class="p">,</span> <span class="n">voxel_values</span><span class="o">=</span><span class="n">phantom_samples</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Phantom&quot;</span><span class="p">)</span>
<span class="n">voxel_grid</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax2</span><span class="p">,</span> <span class="n">voxel_values</span><span class="o">=</span><span class="n">inverted_emission</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Inversion&quot;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

<span class="c1">################################################################################</span>
<span class="c1"># Calculate some metrics for comparison with the phantom</span>
<span class="c1">################################################################################</span>
<span class="n">back_calculated_measurements</span> <span class="o">=</span> <span class="n">sensitivity_matrix</span> <span class="o">@</span> <span class="n">inverted_emission</span>
<span class="n">phantom_measurements</span> <span class="o">=</span> <span class="n">sensitivity_matrix</span> <span class="o">@</span> <span class="n">phantom_samples</span>
<span class="n">cell_volumes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">((</span><span class="n">cell</span><span class="o">.</span><span class="n">volume</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">voxel_grid</span><span class="p">),</span> <span class="s1">&#39;float&#39;</span><span class="p">)</span>
<span class="n">total_phantom_power</span> <span class="o">=</span> <span class="n">phantom_samples</span> <span class="o">@</span> <span class="n">cell_volumes</span>
<span class="n">total_inversion_power</span> <span class="o">=</span> <span class="n">inverted_emission</span> <span class="o">@</span> <span class="n">cell_volumes</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">observations</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Ray-traced measurements&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">phantom_measurements</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Voxel-based measurements&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">back_calculated_measurements</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Back-calculated from inversion&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Foil&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Power / W&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Phantom total power: </span><span class="si">{:.4g}</span><span class="s2">W&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">total_phantom_power</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Inversion total power: </span><span class="si">{:.4g}</span><span class="s2">W&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">total_inversion_power</span><span class="p">))</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>The demo prints the total power calculated from the phantom emissivity profile and the
inverted profile. There is good agreement between the two, with only a 4% discrepancy.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">Measuring the radiation with the bolometers...</span>
<span class="go">Performing inversion...</span>
<span class="go">Plotting results...</span>
<span class="go">Phantom total power: 4.838W</span>
<span class="go">Inversion total power: 5.03W</span>
</pre></div>
</div>
<figure class="align-center" id="id1">
<img alt="../../_images/inversion_with_voxels_profile.png" src="../../_images/inversion_with_voxels_profile.png" />
<figcaption>
<p><span class="caption-text"><strong>Caption</strong> The input and reconstructed emissivity profiles. The general profile
shape is preserved, with the central blob and ring radiator visible in the
inversion. There are a few artefacts around the edge of the reconstruction volume,
particularly near the bottom. Note also that there is more blurring of the boundary
between the central and ring radiators in the upper half of the image: this reflects
the fact that the bolometer sightlines are not symmetric above and below the
midplane.</span><a class="headerlink" href="#id1" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center" id="id2">
<img alt="../../_images/bolometer_voxel_calculated_powers.svg" src="../../_images/bolometer_voxel_calculated_powers.svg" /><figcaption>
<p><span class="caption-text"><strong>Caption</strong> The forward-modelled and back-calculated power measurements on the foils.
The measured power using ray tracing in this script, the calculated power by
multiplying the sensitivity matrix by the emission vector and the back-calculated
power calculated by multiplying the sensitivity matrix by the inverted emissivity are
all in good agreement, showing that the voxel size and the amount of regularisation
are suitable in this case.</span><a class="headerlink" href="#id2" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
</section>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2024, Cherab Team

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
    

  

  <script type="text/javascript" src="../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>


<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Symmetric Power Load Calculation &mdash; CHERAB 1.01 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> CHERAB
          

          
          </a>

          
            
            
              <div class="version">
                1.01
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Table of Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../welcome.html">1. Welcome</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../licence.html">2. Licence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation_and_structure.html">3. Installation and Project Structure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../available_modules.html">4. Available Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../atomic/atomic_data.html">5. Atomic Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../plasmas/plasmas.html">6. Plasmas</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../models/emission_models.html">7. Emission Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../math/math.html">8. Function Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/tools.html">9. Tools</a></li>
</ul>
<p class="caption"><span class="caption-text">Demonstrations</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../demonstrations.html">Atomic Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../demonstrations.html#creating-plasmas">Creating Plasmas</a></li>
<li class="toctree-l1"><a class="reference internal" href="../demonstrations.html#surface-radiation-loads">Surface Radiation Loads</a></li>
<li class="toctree-l1"><a class="reference internal" href="../demonstrations.html#active-spectroscopy">Active Spectroscopy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../demonstrations.html#passive-spectroscopy">Passive Spectroscopy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../demonstrations.html#code-examples-gallery">Code examples gallery</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">CHERAB</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
      <li>Symmetric Power Load Calculation</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/demonstrations/radiation_loads/symmetric_power_load.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="symmetric-power-load-calculation">
<span id="symmetric-power-load"></span><h1>Symmetric Power Load Calculation<a class="headerlink" href="#symmetric-power-load-calculation" title="Permalink to this headline">¶</a></h1>
<p>In this example we perform a simple radiation load calculation by exploiting
symmetry, building on the previous examples. We use an analytic
<a class="reference internal" href="radiation_function.html#radiation-function"><span class="std std-ref">radiation function</span></a> combined with a simple
<a class="reference internal" href="wall_from_polygon.html#wall-from-polygon"><span class="std std-ref">toroidal wall</span></a>. The actual wall detectors are
constructed manually using the Raysect Pixel detector class.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Observing surface are transparent in Raysect. Rays are launched from these
surfaces, but Ray’s don’t collide with them. If you want them to act as
absorbers you need to separately add an absorbing surface. To avoid numerical
issues, its important that these surfaces are slightly displaced. If they
overlap, some rays will become trapped within the surface due to numerical
rounding, leading to faulty calculations. Its best to separate these surfaces
with some small numerical scale length.</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="kn">from</span> <span class="nn">raysect.core</span> <span class="k">import</span> <span class="n">Point2D</span><span class="p">,</span> <span class="n">Point3D</span><span class="p">,</span> <span class="n">translate</span><span class="p">,</span> <span class="n">Vector3D</span><span class="p">,</span> <span class="n">rotate_basis</span>
<span class="kn">from</span> <span class="nn">raysect.optical</span> <span class="k">import</span> <span class="n">World</span><span class="p">,</span> <span class="n">Spectrum</span>
<span class="kn">from</span> <span class="nn">raysect.primitive</span> <span class="k">import</span> <span class="n">Cylinder</span>
<span class="kn">from</span> <span class="nn">raysect.optical.observer</span> <span class="k">import</span> <span class="n">PowerPipeline0D</span>
<span class="kn">from</span> <span class="nn">raysect.optical.observer.nonimaging.pixel</span> <span class="k">import</span> <span class="n">Pixel</span>
<span class="kn">from</span> <span class="nn">raysect.optical.material</span> <span class="k">import</span> <span class="n">AbsorbingSurface</span>

<span class="kn">from</span> <span class="nn">cherab.core.math</span> <span class="k">import</span> <span class="n">sample2d</span><span class="p">,</span> <span class="n">AxisymmetricMapper</span>
<span class="kn">from</span> <span class="nn">cherab.tools.emitters</span> <span class="k">import</span> <span class="n">RadiationFunction</span>
<span class="kn">from</span> <span class="nn">cherab.tools.primitives</span> <span class="k">import</span> <span class="n">axisymmetric_mesh_from_polygon</span>


<span class="c1">#############################</span>
<span class="c1"># define radiation function #</span>

<span class="n">PLASMA_AXIS</span> <span class="o">=</span> <span class="n">Point2D</span><span class="p">(</span><span class="mf">1.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">PLASMA_AXIS_3D</span> <span class="o">=</span> <span class="n">Point3D</span><span class="p">(</span><span class="n">PLASMA_AXIS</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">PLASMA_AXIS</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>  <span class="c1"># convert the plasma_axis in a 3D point</span>
<span class="n">LCFS_RADIUS</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">RING_RADIUS</span> <span class="o">=</span> <span class="mf">0.5</span>

<span class="n">RADIATION_PEAK</span> <span class="o">=</span> <span class="mf">1e6</span>
<span class="n">CENTRE_PEAK_WIDTH</span> <span class="o">=</span> <span class="mf">0.05</span>
<span class="n">RING_WIDTH</span> <span class="o">=</span> <span class="mf">0.025</span>

<span class="c1"># distance of wall from LCFS</span>
<span class="n">WALL_LCFS_OFFSET</span> <span class="o">=</span> <span class="mf">0.1</span>

<span class="c1"># distance of detector pixels from wall</span>
<span class="c1"># slightly displaced to avoid numerical overlap (ray trapping)</span>
<span class="n">WALL_DETECTOR_OFFSET</span> <span class="o">=</span> <span class="mf">0.001</span>

<span class="n">CYLINDER_RADIUS</span> <span class="o">=</span> <span class="n">PLASMA_AXIS</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">LCFS_RADIUS</span> <span class="o">+</span> <span class="n">WALL_LCFS_OFFSET</span> <span class="o">*</span> <span class="mf">1.1</span>
<span class="n">CYLINDER_HEIGHT</span> <span class="o">=</span> <span class="p">(</span><span class="n">LCFS_RADIUS</span> <span class="o">+</span> <span class="n">WALL_LCFS_OFFSET</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>
<span class="n">WALL_RADIUS</span> <span class="o">=</span> <span class="n">LCFS_RADIUS</span> <span class="o">+</span> <span class="n">WALL_LCFS_OFFSET</span>
<span class="n">DETECTOR_RADIUS</span> <span class="o">=</span> <span class="n">WALL_RADIUS</span> <span class="o">-</span> <span class="n">WALL_DETECTOR_OFFSET</span>


<span class="k">def</span> <span class="nf">rad_function</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>

    <span class="n">sample_point</span> <span class="o">=</span> <span class="n">Point2D</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="n">direction</span> <span class="o">=</span> <span class="n">PLASMA_AXIS</span><span class="o">.</span><span class="n">vector_to</span><span class="p">(</span><span class="n">sample_point</span><span class="p">)</span>
    <span class="n">bearing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">direction</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">direction</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># calculate radius of coordinate from magnetic axis</span>
    <span class="n">radius_from_axis</span> <span class="o">=</span> <span class="n">direction</span><span class="o">.</span><span class="n">length</span>
    <span class="n">closest_ring_point</span> <span class="o">=</span> <span class="n">PLASMA_AXIS</span> <span class="o">+</span> <span class="p">(</span><span class="n">direction</span><span class="o">.</span><span class="n">normalise</span><span class="p">()</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>
    <span class="n">radius_from_ring</span> <span class="o">=</span> <span class="n">sample_point</span><span class="o">.</span><span class="n">distance_to</span><span class="p">(</span><span class="n">closest_ring_point</span><span class="p">)</span>

    <span class="c1"># evaluate pedestal-&gt; core function</span>
    <span class="k">if</span> <span class="n">radius_from_axis</span> <span class="o">&lt;=</span> <span class="n">LCFS_RADIUS</span><span class="p">:</span>

        <span class="n">central_radiatior</span> <span class="o">=</span> <span class="n">RADIATION_PEAK</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">radius_from_axis</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">CENTRE_PEAK_WIDTH</span><span class="p">)</span>

        <span class="n">ring_radiator</span> <span class="o">=</span> <span class="n">RADIATION_PEAK</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">bearing</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">radius_from_ring</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">RING_WIDTH</span><span class="p">)</span>
        <span class="n">ring_radiator</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ring_radiator</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">central_radiatior</span> <span class="o">+</span> <span class="n">ring_radiator</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>


<span class="c1"># add radiation source to world</span>
<span class="n">rad_function_3d</span> <span class="o">=</span> <span class="n">AxisymmetricMapper</span><span class="p">(</span><span class="n">rad_function</span><span class="p">)</span>
<span class="n">radiation_emitter</span> <span class="o">=</span> <span class="n">RadiationFunction</span><span class="p">(</span><span class="n">rad_function_3d</span><span class="p">,</span> <span class="n">vertical_offset</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

<span class="n">world</span> <span class="o">=</span> <span class="n">World</span><span class="p">()</span>
<span class="n">geom</span> <span class="o">=</span> <span class="n">Cylinder</span><span class="p">(</span><span class="n">CYLINDER_RADIUS</span><span class="p">,</span> <span class="n">CYLINDER_HEIGHT</span><span class="p">,</span>
                <span class="n">transform</span><span class="o">=</span><span class="n">translate</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">parent</span><span class="o">=</span><span class="n">world</span><span class="p">,</span> <span class="n">material</span><span class="o">=</span><span class="n">radiation_emitter</span><span class="p">)</span>


<span class="c1">############################################</span>
<span class="c1"># make a toroidal wall wrapping the plasma #</span>

<span class="c1"># number of poloidal wall elements</span>
<span class="n">n_poloidal</span> <span class="o">=</span> <span class="mi">250</span>
<span class="n">d_angle</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_poloidal</span>

<span class="n">wall_polygon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_poloidal</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_poloidal</span><span class="p">):</span>
    <span class="n">pr</span> <span class="o">=</span> <span class="n">PLASMA_AXIS</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">WALL_RADIUS</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">d_angle</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span>
    <span class="n">pz</span> <span class="o">=</span> <span class="n">PLASMA_AXIS</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">WALL_RADIUS</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">d_angle</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span>
    <span class="n">wall_polygon</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">pr</span><span class="p">,</span> <span class="n">pz</span>
<span class="n">wall_polygon</span> <span class="o">=</span> <span class="n">wall_polygon</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># make surface normals point inwards</span>

<span class="c1"># create a 3D mesh from the 2D polygon outline using symmetry</span>
<span class="n">wall_mesh</span> <span class="o">=</span> <span class="n">axisymmetric_mesh_from_polygon</span><span class="p">(</span><span class="n">wall_polygon</span><span class="p">)</span>
<span class="n">wall_mesh</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">world</span>
<span class="n">wall_mesh</span><span class="o">.</span><span class="n">material</span> <span class="o">=</span> <span class="n">AbsorbingSurface</span><span class="p">()</span>


<span class="c1">###################################################</span>
<span class="c1"># make detectors wrapping a slice of wall surface #</span>

<span class="c1"># toroidal width of the detectors</span>
<span class="n">X_WIDTH</span> <span class="o">=</span> <span class="mf">0.01</span>

<span class="c1"># intialization of the initial angle</span>
<span class="n">d_angle</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_poloidal</span>

<span class="c1"># visualise emission adn detectors</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">r</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">t_samples</span> <span class="o">=</span> <span class="n">sample2d</span><span class="p">(</span><span class="n">rad_function</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">200</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">200</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">t_samples</span><span class="p">)),</span> <span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;r axis&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;z axis&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Radiation profile in r-z plane&quot;</span><span class="p">)</span>

<span class="n">wall_detectors</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_poloidal</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>

    <span class="n">p1x</span> <span class="o">=</span> <span class="n">PLASMA_AXIS</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">DETECTOR_RADIUS</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">d_angle</span> <span class="o">*</span> <span class="n">index</span><span class="p">)</span>
    <span class="n">p1y</span> <span class="o">=</span> <span class="n">PLASMA_AXIS</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">DETECTOR_RADIUS</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">d_angle</span> <span class="o">*</span> <span class="n">index</span><span class="p">)</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="n">Point3D</span><span class="p">(</span><span class="n">p1x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">p1y</span><span class="p">)</span>

    <span class="n">p2x</span> <span class="o">=</span> <span class="n">PLASMA_AXIS</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">DETECTOR_RADIUS</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">d_angle</span> <span class="o">*</span> <span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">p2y</span> <span class="o">=</span> <span class="n">PLASMA_AXIS</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">DETECTOR_RADIUS</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">d_angle</span> <span class="o">*</span> <span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">p2</span> <span class="o">=</span> <span class="n">Point3D</span><span class="p">(</span><span class="n">p2x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">p2y</span><span class="p">)</span>

    <span class="c1"># evaluate y_vector</span>
    <span class="n">y_vector_full</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="n">vector_to</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span>
    <span class="n">y_vector</span> <span class="o">=</span> <span class="n">y_vector_full</span><span class="o">.</span><span class="n">normalise</span><span class="p">()</span>
    <span class="n">y_width</span> <span class="o">=</span> <span class="n">y_vector_full</span><span class="o">.</span><span class="n">length</span>

    <span class="c1"># evaluate the central point of the detector</span>
    <span class="n">detector_center</span> <span class="o">=</span> <span class="n">p1</span> <span class="o">+</span> <span class="n">y_vector_full</span> <span class="o">*</span> <span class="mf">0.5</span>

    <span class="c1"># evaluate normal_vector</span>
    <span class="n">normal_vector</span> <span class="o">=</span> <span class="p">(</span><span class="n">detector_center</span><span class="o">.</span><span class="n">vector_to</span><span class="p">(</span><span class="n">PLASMA_AXIS_3D</span><span class="p">))</span><span class="o">.</span><span class="n">normalise</span><span class="p">()</span>  <span class="c1"># inward pointing</span>

    <span class="c1"># to populate it step by step</span>
    <span class="n">wall_detectors</span> <span class="o">=</span> <span class="n">wall_detectors</span> <span class="o">+</span> <span class="p">[((</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">X_WIDTH</span><span class="p">,</span> <span class="n">y_width</span><span class="p">,</span> <span class="n">detector_center</span><span class="p">,</span> <span class="n">normal_vector</span><span class="p">,</span> <span class="n">y_vector</span><span class="p">)]</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">p1x</span><span class="p">,</span> <span class="n">p2x</span><span class="p">],</span> <span class="p">[</span><span class="n">p1y</span><span class="p">,</span> <span class="n">p2y</span><span class="p">],</span> <span class="s1">&#39;k&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">p1x</span><span class="p">,</span> <span class="n">p2x</span><span class="p">],</span> <span class="p">[</span><span class="n">p1y</span><span class="p">,</span> <span class="n">p2y</span><span class="p">],</span> <span class="s1">&#39;.k&#39;</span><span class="p">)</span>
    <span class="n">pc</span> <span class="o">=</span> <span class="n">detector_center</span>
    <span class="n">pcn</span> <span class="o">=</span> <span class="n">pc</span> <span class="o">+</span> <span class="n">normal_vector</span> <span class="o">*</span> <span class="mf">0.05</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">pc</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pcn</span><span class="o">.</span><span class="n">x</span><span class="p">],</span> <span class="p">[</span><span class="n">pc</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">pcn</span><span class="o">.</span><span class="n">z</span><span class="p">],</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>


<span class="c1">##############################################################</span>
<span class="c1"># iterate through all detectors and calculate radiation load #</span>

<span class="c1"># storage lists for results</span>
<span class="n">power_densities</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">detector_numbers</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">distance</span> <span class="o">=</span> <span class="p">[]</span>

<span class="n">running_distance</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">observed_total_power</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1"># loop over each tile detector</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">detector</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">wall_detectors</span><span class="p">):</span>

    <span class="nb">print</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;detector </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>

    <span class="c1"># extract the dimensions and orientation of the tile</span>
    <span class="n">y_width</span> <span class="o">=</span> <span class="n">detector</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">centre_point</span> <span class="o">=</span> <span class="n">detector</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">normal_vector</span> <span class="o">=</span> <span class="n">detector</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
    <span class="n">y_vector</span> <span class="o">=</span> <span class="n">detector</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
    <span class="n">pixel_area</span> <span class="o">=</span> <span class="n">X_WIDTH</span> <span class="o">*</span> <span class="n">y_width</span>

    <span class="c1"># Use the power pipeline to record total power arriving at the surface</span>
    <span class="n">power_data</span> <span class="o">=</span> <span class="n">PowerPipeline0D</span><span class="p">()</span>

    <span class="n">pixel_transform</span> <span class="o">=</span> <span class="n">translate</span><span class="p">(</span><span class="n">centre_point</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">centre_point</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">centre_point</span><span class="o">.</span><span class="n">z</span><span class="p">)</span> <span class="o">*</span> <span class="n">rotate_basis</span><span class="p">(</span><span class="n">normal_vector</span><span class="p">,</span> <span class="n">y_vector</span><span class="p">)</span>
    <span class="c1"># Use pixel_samples argument to increase amount of sampling and reduce noise</span>
    <span class="n">pixel</span> <span class="o">=</span> <span class="n">Pixel</span><span class="p">([</span><span class="n">power_data</span><span class="p">],</span> <span class="n">x_width</span><span class="o">=</span><span class="n">X_WIDTH</span><span class="p">,</span> <span class="n">y_width</span><span class="o">=</span><span class="n">y_width</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;pixel-</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>
                  <span class="n">spectral_bins</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">pixel_transform</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">world</span><span class="p">,</span> <span class="n">pixel_samples</span><span class="o">=</span><span class="mi">2000</span><span class="p">)</span>
    <span class="c1"># make detector sensitivity 1nm so that raditation function is effectively W/m^3/str</span>

    <span class="c1"># Start collecting samples</span>
    <span class="n">pixel</span><span class="o">.</span><span class="n">observe</span><span class="p">()</span>

    <span class="c1"># Append the collected data to the storage lists</span>
    <span class="n">power_density</span> <span class="o">=</span> <span class="n">power_data</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">mean</span> <span class="o">/</span> <span class="n">pixel_area</span>
    <span class="n">power_densities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">power_density</span><span class="p">)</span>  <span class="c1"># convert to W/m^2 !!!!!!!!!!!!!!!!!!!</span>

    <span class="n">detector_numbers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="n">running_distance</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">y_width</span> <span class="c1"># with Y_WIDTH instead of y_width</span>
    <span class="n">distance</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">running_distance</span><span class="p">)</span>
    <span class="n">running_distance</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">y_width</span> <span class="c1"># with Y_WIDTH instead of y_width</span>

    <span class="c1"># For checking energy conservation.</span>
    <span class="c1"># Revolve this tile around the CYLINDRICAL z-axis to get total power collected by these tiles.</span>
    <span class="c1"># Add up all the tile contributions to get total power collected.</span>
    <span class="n">detector_radius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">centre_point</span><span class="o">.</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">centre_point</span><span class="o">.</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">observed_total_power</span> <span class="o">+=</span> <span class="n">power_density</span> <span class="o">*</span> <span class="p">(</span><span class="n">y_width</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">detector_radius</span><span class="p">)</span>


<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">power_densities</span><span class="p">)</span><span class="o">/</span><span class="mf">1e3</span><span class="p">,</span> <span class="s1">&#39;b-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;average&#39;</span><span class="p">)</span> <span class="c1"># average</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;y coordinate [m]&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;power per unit area [kW/m^2]&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Surface Power Loading&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>


<span class="c1">########################################################################################################################</span>

<span class="c1"># **********************************CHECK ENERGY CONSERVATION*************************************</span>

<span class="c1"># initializations</span>
<span class="n">emitted_total_power</span> <span class="o">=</span> <span class="mi">0</span>

<span class="n">num_vertical_points</span> <span class="o">=</span> <span class="mi">500</span>
<span class="n">vertical_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">num_vertical_points</span><span class="p">)</span>
<span class="n">num_radial_points</span> <span class="o">=</span> <span class="mi">500</span>
<span class="n">radial_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">num_radial_points</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_radial_points</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_vertical_points</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>

        <span class="n">p1</span> <span class="o">=</span> <span class="n">Point2D</span><span class="p">(</span><span class="n">radial_points</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">vertical_points</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="n">Point2D</span><span class="p">(</span><span class="n">radial_points</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">vertical_points</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">p3</span> <span class="o">=</span> <span class="n">Point2D</span><span class="p">(</span><span class="n">radial_points</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">vertical_points</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">p4</span> <span class="o">=</span> <span class="n">Point2D</span><span class="p">(</span><span class="n">radial_points</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">vertical_points</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

        <span class="n">pc</span> <span class="o">=</span> <span class="n">Point2D</span><span class="p">((</span><span class="n">p1</span><span class="o">.</span><span class="n">x</span><span class="o">+</span><span class="n">p2</span><span class="o">.</span><span class="n">x</span><span class="o">+</span><span class="n">p3</span><span class="o">.</span><span class="n">x</span><span class="o">+</span><span class="n">p4</span><span class="o">.</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="p">(</span><span class="n">p1</span><span class="o">.</span><span class="n">y</span><span class="o">+</span><span class="n">p2</span><span class="o">.</span><span class="n">y</span><span class="o">+</span><span class="n">p3</span><span class="o">.</span><span class="n">y</span><span class="o">+</span><span class="n">p4</span><span class="o">.</span><span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span>

        <span class="c1"># cell_volume = area of cell * circumference at cell radius</span>
        <span class="n">cell_volume</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="n">distance_to</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span> <span class="o">*</span> <span class="n">p1</span><span class="o">.</span><span class="n">distance_to</span><span class="p">(</span><span class="n">p4</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">pc</span><span class="o">.</span><span class="n">x</span>

        <span class="n">emitted_rad_data</span> <span class="o">=</span> <span class="n">rad_function</span><span class="p">(</span><span class="n">pc</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pc</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        <span class="n">emitted_total_power</span> <span class="o">+=</span> <span class="n">emitted_rad_data</span> <span class="o">*</span> <span class="n">cell_volume</span>

<span class="nb">print</span><span class="p">()</span>
<span class="nb">print</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Total radiated power =&gt; </span><span class="si">{:.4G}</span><span class="s2"> MW&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">emitted_total_power</span><span class="o">/</span><span class="mf">1e6</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;CHERAB total detected power =&gt; </span><span class="si">{:.4G}</span><span class="s2"> MW&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">observed_total_power</span><span class="o">/</span><span class="mf">1e6</span><span class="p">))</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>When this script is run, the output confirms power is conserved.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">python</span> <span class="n">symmetric_power_load</span><span class="o">.</span><span class="n">py</span>
<span class="go">Total radiated power =&gt; 4.848 MW</span>
<span class="go">CHERAB total detected power =&gt; 4.844 MW</span>
</pre></div>
</div>
<div class="figure align-center" id="id1">
<img alt="../../_images/symmetric_power_load_detectors.png" src="../../_images/symmetric_power_load_detectors.png" />
<p class="caption"><span class="caption-text"><strong>Caption:</strong> The emission source function with the wall detector positions
overlaid.</span></p>
</div>
<div class="figure align-center" id="id2">
<img alt="../../_images/symmetric_power_load_zoomed_detectors.png" src="../../_images/symmetric_power_load_zoomed_detectors.png" />
<p class="caption"><span class="caption-text"><strong>Caption:</strong> A zoomed in view of the wall detectors (black) and their surface
normals (red).</span></p>
</div>
<div class="figure align-center" id="id3">
<img alt="../../_images/symmetric_power_load1.png" src="../../_images/symmetric_power_load1.png" />
<p class="caption"><span class="caption-text"><strong>Caption:</strong> The power loading in MW/m^2 measured on the pixel detectors wrapping
around the wall.</span></p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, CHERAB Team.

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'1.01',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>